/* -*-c++-*- */
/* osgEarth - Geospatial SDK for OpenSceneGraph
 * Copyright 2018 Pelican Mapping
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */

#ifndef OSGEARTH_TERRAIN_LAYER_H
#define OSGEARTH_TERRAIN_LAYER_H 1

#include <osgEarth/Common>
#include <osgEarth/CachePolicy>
#include <osgEarth/Config>
#include <osgEarth/VisibleLayer>
#include <osgEarth/TileSource>
#include <osgEarth/Profile>
#include <osgEarth/ThreadingUtils>
#include <osgEarth/HTTPClient>
#include <osgEarth/Status>

namespace osgEarth
{
    class Cache;
    class CacheBin;
    class MemCache;

    struct TerrainLayerCallback : public VisibleLayerCallback
    {
        typedef void(TerrainLayerCallback::*MethodPtr)(class TerrainLayer*);
    };

    /**
     * A layer that comprises the terrain skin (image or elevation layer)
     */
    class OSGEARTH_EXPORT TerrainLayer : public VisibleLayer
    {
    public: // serialization
        class OSGEARTH_EXPORT Options : public VisibleLayer::Options {
        public:
            META_LayerOptions(osgEarth, Options, VisibleLayer::Options);
            OE_OPTION(TileSourceOptions, driver);
            OE_OPTION(unsigned, minLevel);
            OE_OPTION(double, minResolution);
            OE_OPTION(unsigned, maxLevel);
            OE_OPTION(double, maxResolution);
            OE_OPTION(unsigned, maxDataLevel);
            OE_OPTION(ProxySettings, proxySettings);
            OE_OPTION(unsigned, tileSize);
            OE_OPTION(float, noDataValue);
            OE_OPTION(float, minValidValue);
            OE_OPTION(float, maxValidValue);
            OE_OPTION(ProfileOptions, profile);
            virtual Config getConfig() const;
        private:
            void fromConfig( const Config& conf );
        };

    public:
        META_Layer_Abstract(osgEarth, TerrainLayer, Options, VisibleLayer);

        //! Minimum of detail for which this layer should generate data.
        void setMinLevel(const unsigned& value);
        const unsigned& getMinLevel() const;

        //! Minimum resolution for which this layer should generate data.
        void setMinResolution(const double& value);
        const double& getMinResolution() const;

        //! Maximum level of detail for which this layer should generate data.
        //! Data from this layer will not appear in map tiles above the maxLevel.
        void setMaxLevel(const unsigned& value);
        const unsigned& getMaxLevel() const;

        //! Maximum level resolution for which this layer should generate data.
        //! The value is in units per pixel, using the base units of the layer's source data.
        void setMaxResolution(const double& value);
        const double& getMaxResolution() const;

        //! Maximum level of detail for which this layer should generate new data.
        //! Data from this layer will be upsampled in map tiles above the maxDataLevel.
        void setMaxDataLevel(const unsigned& value);
        const unsigned& getMaxDataLevel() const;

        //! Number of samples in each dimension.
        void setTileSize(const unsigned& value);
        virtual unsigned getTileSize() const;

        //! Value to treat as a "no data" marker.
        void setNoDataValue(const float& value);
        virtual float getNoDataValue() const;

        //! Treat any value less than this as a "no data" marker.
        void setMinValidValue(const float& value);
        virtual float getMinValidValue() const;

        //! Treat any value greater than this as a "no data" marker.
        void setMaxValidValue(const float& value);
        virtual float getMaxValidValue() const;

    protected:
        //! DTOR
        virtual ~TerrainLayer();

    public: // Layer

        /** Opens the layer and initializes the data source. */
        virtual const Status& open();

        //! Cache ID for this layer
        virtual std::string getCacheID() const;


    public:

        //! Geospatial profile for this layer
        const Profile* getProfile() const;

        //! Geospatial profile of this layer. Many layer types will set this
        //! automatically based on source metadata. For those that don't you can
        //! call it directly to set up a profile.
        void setProfile(const Profile* profile);


        //! Install a tile source instance.
        void setTileSource(TileSource* tileSource);

        /**
         * Gets the underlying TileSource engine that serves this map layer. Use with caution.
         */
        TileSource* getTileSource() const;

        /**
         * Whether the layer represents dynamic data, i.e. it generates data that requires
         * an update traversal.
         */
        virtual bool isDynamic() const;

        /** Attribution to be displayed by the application */
        virtual std::string getAttribution() const;

        /**
         * Whether the data for the specified tile key is in the cache.
         */
        virtual bool isCached(const TileKey& key) const;

        /**
         * Gives the terrain layer a hint as to what the target profile of
         * images will be. This is optional, but it may allow the layer to enable
         * certain optimizations since it has more information as to how the
         * data will be used.
         */
        virtual void setTargetProfileHint( const Profile* profile );

        /**
         * Disable this layer, setting an error status.
         */
        void disable(const std::string& msg);

        /**
         * Sets the I/O options to use. This data may include cache information.
         */
        void setReadOptions(const osgDB::Options* readOptions);


    public: // Data availability methods

        /**
         * Given a TileKey, returns a TileKey representing the best known available.
         * For example, if the input TileKey exceeds the layer's max LOD, the return
         * value will be an ancestor key at that max LOD.
         *
         * If a setting that effects the visible range of this layer is set (minLevel, maxLevel, minResolution or maxResolution)
         * then any key passed in that falls outside of the valid range for the layer will return TileKey::INVALID.
         */
        virtual TileKey getBestAvailableTileKey(const TileKey& key) const;

        /**
         * Whether the layer possibly has real data for the provided TileKey.
         * Best guess given available information.
         */
        virtual bool mayHaveData(const TileKey& key) const;

        /**
         * Whether the given key falls within the range limits set in the options;
         * i.e. min/maxLevel or min/maxResolution. (This does not mean that the key
         * will result in data.)
         */
        virtual bool isKeyInLegalRange(const TileKey& key) const;

        /**
         * Data Extents reported for this layer are copied into output.
         * Returns true on success, false is there are no extents to report.
         */
        const DataExtentList& getDataExtents() const;

        /**
         * Gets an extent that is the union of all the extents in getDataExtents().
         */
        const GeoExtent& getDataExtentsUnion() const;

    public: // Layer interface

        virtual SequenceControl* getSequenceControl();

    public:

        /**
         * Metadata about the terrain layer that is stored in the cache, and read
         * when the cache is opened.
         */
        struct OSGEARTH_EXPORT CacheBinMetadata : public osg::Referenced
        {
            CacheBinMetadata();

            CacheBinMetadata( const CacheBinMetadata& rhs );

            CacheBinMetadata( const Config& conf );

            bool isOK() const { return _valid; }

            Config getConfig() const;

            bool                     _valid;
            optional<std::string>    _cacheBinId;
            optional<std::string>    _sourceName;
            optional<std::string>    _sourceDriver;
            optional<int>            _sourceTileSize;
            optional<ProfileOptions> _sourceProfile;
            optional<ProfileOptions> _cacheProfile;
            optional<TimeStamp>      _cacheCreateTime;
            DataExtentList           _dataExtents;
        };

        /**
         * Access to information about the cache
         */
        CacheBinMetadata* getCacheBinMetadata(const Profile* profile);

        /**
         * Cache Settings for this layer - guaranteed to return an object
         */
        CacheSettings* getCacheSettings() const;

    protected: // Layer

        // CTOR initialization; call from subclass.
        virtual void init();

        //! Extent of this layer's data.
        virtual const GeoExtent& getExtent() const;

    protected:

        //! Creates the driver the supplies the actual data.
        //! By default, this function will either return the tile source passed
        //! into the CTOR or it will try to load it from a plugin based on the
        //! driver specification in the TileSourceOptions. You can override this
        //! method to create your own tile source.
        virtual TileSource* createTileSource();

        //! Opportunity for a subclass to alter and/or override components
        //! of the Profile
        virtual void applyProfileOverrides() { }

        //! Gets or create a caching bin to use with data in the supplied profile
        CacheBin* getCacheBin(const Profile* profile);

        //! Mutable access to the data extents for this layer
        DataExtentList& dataExtents();

        //! Call this if you call dataExtents() and modify it.
        void dirtyDataExtents();

    protected:

        osg::ref_ptr<const Profile>    _targetProfileHint;
        unsigned                       _tileSize;
        osg::ref_ptr<MemCache>         _memCache;
        bool _openCalled;

        // profile from tile source or cache, before any overrides applied
        mutable osg::ref_ptr<const Profile> _profileOriginal;

        // profile to use
        mutable osg::ref_ptr<const Profile> _profile;

        // cache key for metadata
        std::string getMetadataKey(const Profile*) const;

        // Called by a subclass before open() to indicate whether this
        // layer should try to open a tile source and fail if unsuccesful.
        void setTileSourceExpected(bool value) { _tileSourceExpected = value; }

        //! Whether this layer expected a tilesource to be installed
        bool isTileSourceExpected() const { return _tileSourceExpected; }

    private:
        bool                     _tileSourceExpected;
        mutable Threading::Mutex _initTileSourceMutex;
        osg::ref_ptr<TileSource> _tileSource;
        DataExtentList           _dataExtents;
        mutable GeoExtent        _dataExtentsUnion;

        // The cache ID used at runtime. This will either be the cacheId found in
        // the TerrainLayerOptions, or a dynamic cacheID generated at runtime.
        std::string _runtimeCacheId;

        // cache policy that may be automatically set by the layer and will
        // override the runtime options policy if set.
        optional<CachePolicy> _runtimeCachePolicy;

        typedef std::map<std::string, osg::ref_ptr<CacheBinMetadata> > CacheBinMetadataMap;
        CacheBinMetadataMap _cacheBinMetadata;

        mutable Threading::Mutex _mutex;

        mutable osg::ref_ptr<CacheSettings> _cacheSettings;

        // methods accesible by Map:
        friend class Map;
        void storeProxySettings( osgDB::Options* );

        // read the tile source's cache policy hint and apply as necessary
        void refreshTileSourceCachePolicyHint(TileSource*);

        TileSource* createAndOpenTileSource();

        // Figure out the cache settings for this layer.
        void establishCacheSettings();

    protected:
        /** Closes the layer, deleting its tile source and any other resources. */
        virtual void close();

    };

    typedef std::vector<osg::ref_ptr<TerrainLayer> > TerrainLayerVector;

} // namespace TerrainLayer

#endif // OSGEARTH_TERRAIN_LAYER_H
