/* -*-c++-*- */
/* osgEarth - Geospatial SDK for OpenSceneGraph
* Copyright 2020 Pelican Mapping
* http://osgearth.org
*
* osgEarth is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>
*/
#ifndef OSGEARTH_TEXTURE_ARENA_H
#define OSGEARTH_TEXTURE_ARENA_H 1

#include <osgEarth/Common>
#include <osgEarth/GLUtils>
#include <osgEarth/URI>
#include <osg/Object>
#include <osg/StateAttribute>
#include <osg/buffered_value>
#include <osg/Image>
#include <unordered_map>
#include <unordered_set>
#include <queue>

namespace osgEarth
{
    /**
     * A texture that can be GPU-resident or not. Managed by a TextureArena.
     *
     * Stages of residency:
     * 1. Not resident - only the URI is set
     * 2. CPU resident - osg::Image is loaded into memory
     * 3. GPU resident - GPU handle is in GPU table; GPU memory might not be allocated
     * 4. GPU commited - GPU handle active, GPU texture fully available
     */
    class OSGEARTH_EXPORT Texture : public osg::Referenced
    {
    public:
        Texture() : _resident(false), _gltexture(~0UL), _glhandle(~0ULL) { }
        //TODO: API
        optional<URI> _uri;
        osg::ref_ptr<osg::Image> _image;
        mutable optional<GLuint> _gltexture;
        mutable optional<GLuint64> _glhandle;
        mutable bool _resident;

        GLuint64 getHandle() const { return _glhandle.isSet() ? _glhandle.get() : ~0ULL; }
    };


    /**
     * TextureArena is a dynamic bindless texture atlas. Add as many texture
     * as you want and control memory management by activating and deactivating
     * them.
     *
     * Call add() to have the arena start managing a Texture.
     * After that, you can call activate() or deactivate() on individual textures
     * to control their availability on the GPU.
     */
    class OSGEARTH_EXPORT TextureArena : public osg::StateAttribute
    {
    public:
        META_StateAttribute(osgEarth, TextureArena,
            (osg::StateAttribute::Type)(osg::StateAttribute::CAPABILITY+8675309));

        //! Construct an empty arena.
        TextureArena();

        //! Adds a texture to the arena. On next apply() GL handles will allocate.
        //! You only need to call this once for each texture.
        void add(Texture* tex);

        //! Makes a texture fully available on the GPU.
        void activate(Texture* tex);

        //! Removes the texture from the GPU.
        void deactivate(Texture* tex);

        //! Whether compileGLObjects has been called.
        bool isCompiled() const { return _compiled; }

        //! destruct
        virtual ~TextureArena();

    public: // StateAttribute
        void apply(osg::State&) const;
        void compileGLObjects(osg::State&) const;
        void resizeGLObjectBuffers(unsigned);
        void releaseGLObjects(osg::State*) const;
        int compare(const osg::StateAttribute& rhs) const { return -1; }

    private:
        //! disasble copy
        TextureArena(const TextureArena&, const osg::CopyOp&) { } 

        //! allocate handles for all add()ed textures
        void allocate(Texture* texture, osg::State& state) const;

        mutable std::vector<osg::ref_ptr<Texture> > _toAdd;
        mutable std::vector<osg::ref_ptr<Texture> > _toActivate;
        mutable std::vector<osg::ref_ptr<Texture> > _toDeactivate;

        mutable bool _compiled;
    };
}

#endif // OSGEARTH_TEXTURE_ARENA_H
