/* -*-c++-*- */
/* osgEarth - Geospatial SDK for OpenSceneGraph
 * Copyright 2018 Pelican Mapping
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */
#ifndef OSGEARTH_FEATURES_OGRFEATURESOURCE_LAYER
#define OSGEARTH_FEATURES_OGRFEATURESOURCE_LAYER

#include <osgEarthFeatures/FeatureSource>

using namespace osgEarth;
using namespace osgEarth::Features;

/**
 * A FeatureSource that reads features from an OGR driver.
 * This FeatureSource does NOT support styling.
 */
namespace osgEarth { namespace Features
{
    class OSGEARTHFEATURES_EXPORT OGRFeatureSourceOptions : public FeatureSourceOptions
    {
    public:
        META_LayerOptions(osgEarth, OGRFeatureSourceOptions, FeatureSourceOptions);

        optional<URI>& url() { return _url; }
        const optional<URI>& url() const { return _url; }

        optional<std::string>& connection() { return _connection; }
        const optional<std::string>& connection() const { return _connection; }

        optional<std::string>& ogrDriver() { return _ogrDriver; }
        const optional<std::string>& ogrDriver() const { return _ogrDriver; }

        optional<bool>& buildSpatialIndex() { return _buildSpatialIndex; }
        const optional<bool>& buildSpatialIndex() const { return _buildSpatialIndex; }

        optional<bool>& forceRebuildSpatialIndex() { return _forceRebuildSpatialIndex; }
        const optional<bool>& forceRebuildSpatialIndex() const { return _forceRebuildSpatialIndex; }

        optional<Config>& geometryConfig() { return _geometryConf; }
        const optional<Config>& geometryConfig() const { return _geometryConf; }

        optional<std::string>& geometryUrl() { return _geometryUrl; }
        const optional<std::string>& geometryUrl() const { return _geometryUrl; }

        optional<std::string>& layer() { return _layer; }
        const optional<std::string>& layer() const { return _layer; }

        optional<Query>& query() { return _query; }
        const optional<Query>& query() const { return _query; }
        
    public:
        virtual Config getConfig() const;

    private:
        void fromConfig(const Config& conf);
        
        optional<URI>         _url;
        optional<std::string> _connection;
        optional<std::string> _ogrDriver;
        optional<bool>        _buildSpatialIndex;
        optional<bool>        _forceRebuildSpatialIndex;
        optional<Config>      _geometryConf;
        optional<Config>      _geometryProfileConf;
        optional<std::string> _geometryUrl;
        optional<std::string> _layer;
        optional<Query>       _query;
    };

    /**
     * Feature Layer that accesses features via one of the many GDAL/OGR drivers.
     */
    class OSGEARTHFEATURES_EXPORT OGRFeatureSource : public FeatureSource
    {   
    public:
        META_Layer(osgEarth, OGRFeatureSource, OGRFeatureSourceOptions, FeatureSource, ogrfeatures);

    public:

        void setURL(const URI& value) { options().url() = value; }

        void setConnection(const std::string& value) { options().connection() = value; }

        void setBuildSpatialIndex(bool value) { options().buildSpatialIndex() = value; }

        void setGeometry(Symbology::Geometry* geom) { _geometry = geom; }

        void setProfile(const Profile* profile) { _profile = profile; }

        void setOGRDriver(const std::string& value) { options().ogrDriver() = value; }

    public: // Layer

        virtual const Status& open();

        virtual void close();

    protected:

        virtual void init();

    public: // FeatureSource

        virtual FeatureCursor* createFeatureCursor(const Symbology::Query& query, ProgressCallback* progress);        

        virtual bool deleteFeature(FeatureID fid);

        virtual int getFeatureCount() const;

        virtual bool supportsGetFeature() const;

        virtual Feature* getFeature( FeatureID fid );

        virtual bool isWritable() const;

        virtual const FeatureSchema& getSchema() const;
    
        virtual bool insertFeature(Feature* feature);

        virtual osgEarth::Symbology::Geometry::Type getGeometryType() const;

    protected:

        virtual ~OGRFeatureSource();

        // parses an explicit WKT geometry string into a Geometry.
        Symbology::Geometry* parseGeometry( const Config& geomConf );

        // read the WKT geometry from a URL, then parse into a Geometry.
        Symbology::Geometry* parseGeometryUrl( const std::string& geomUrl, const osgDB::Options* dbOptions );

        void initSchema();

    private:
        osg::ref_ptr<const Profile> _profile;
        osg::ref_ptr<Symbology::Geometry> _geometry; // explicit geometry.
        std::string _source;
        void* _dsHandle;
        void* _layerHandle;
        void* _ogrDriverHandle;
        int _featureCount;
        bool _needsSync;
        bool _writable;
        FeatureSchema _schema;
        Geometry::Type _geometryType;

        void ctor();
    };

} } // namespace osgEarth::Features

OSGEARTH_SPECIALIZE_CONFIG(osgEarth::Features::OGRFeatureSourceOptions);

#endif // OSGEARTH_FEATURES_OGRFEATURESOURCE_LAYER
