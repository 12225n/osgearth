/* -*-c++-*- */
/* osgEarth - Geospatial SDK for OpenSceneGraph
 * Copyright 2018 Pelican Mapping
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */
#pragma once

#include <osgEarth/ImGui/ImGui>
#include <osgEarth/BuildConfig>
#include <osgEarth/Config>
#include <osgDB/ReadFile>
#include <osg/observer_ptr>
#include <osg/StateSet>
#include <memory>

namespace osgEarth
{
    // base class for GUI elements that allows you to toggle visibility
    // no export. header only.
    class ImGuiPanel
    {
    public:
        using Ptr = std::shared_ptr<ImGuiPanel>;

    public:
        void setVisible(bool value) {
            _visible = value;
            dirtySettings();
        }

        //! whether it's current shown
        bool isVisible() const {
            return _visible;
        }

        //! name of the GUI panel
        virtual const char* name() const final {
            return _name.c_str();
        }

        //! render this GUI
        virtual void draw(osg::RenderInfo& ri) = 0;

        //! override to set custom values in the .ini file
        virtual void load(const osgEarth::Config&) { }

        //! override to get custom values from the .ini file
        virtual void save(osgEarth::Config&) { }

    protected:
        ImGuiPanel(const char* name) :
            _name(name), _visible(false), _last_visible(false)
        {
            //nop
        }

        //! convenience function for finding nodes
        template<typename T>
        T* findNode(osg::RenderInfo& ri) const {
            return osgEarth::findTopMostNodeOfType<T>(ri.getCurrentCamera());
        }

        //! convenience function for getting the current view
        inline osgViewer::View* view(osg::RenderInfo& ri) const {
            return dynamic_cast<osgViewer::View*>(ri.getView());
        }

        //! convenience function for getting the current camera
        inline osg::Camera* camera(osg::RenderInfo& ri) const {
            return ri.getCurrentCamera();
        }

        //! convenience function for getting the topmost stateset
        inline osg::StateSet* stateset(osg::RenderInfo& ri) const {
            return ri.getCurrentCamera()->getOrCreateStateSet();
        }

        //! convenience function for finding nodes
        template<typename T>
        bool findNode(osg::observer_ptr<T>& node, osg::RenderInfo& ri) const {
            if (!node.valid())
                node = osgEarth::findTopMostNodeOfType<T>(ri.getCurrentCamera());
            return node.valid();
        }

        //! convenience function for finding nodes
        template<typename T>
        bool findNodeOrHide(osg::observer_ptr<T>& node, osg::RenderInfo& ri) {
            if (!node.valid())
                node = osgEarth::findTopMostNodeOfType<T>(ri.getCurrentCamera());
            if (!node.valid())
                setVisible(false);
            return node.valid();
        }

        template<typename T>
        bool findLayer(osg::observer_ptr<T>& layer, osg::RenderInfo& ri) {
            if (!layer.valid()) {
                MapNode* mapNode = osgEarth::findTopMostNodeOfType<MapNode>(ri.getCurrentCamera());
                if (mapNode)
                    layer = mapNode->getMap()->getLayer<T>();
            }
            return layer.valid();
        }

        template<typename T>
        bool findLayerOrHide(osg::observer_ptr<T>& layer, osg::RenderInfo& ri) {
            if (!layer.valid()) {
                MapNode* mapNode = osgEarth::findTopMostNodeOfType<MapNode>(ri.getCurrentCamera());
                if (mapNode)
                    layer = mapNode->getMap()->getLayer<T>();
            }
            if (!layer.valid())
                setVisible(false);
            return layer.valid();
        }

        //! sets a value and dirties the .ini store
        template<typename A, typename B>
        void set_and_dirty(A& var, const B& value)
        {
            if (var != value) {
                var = value;
                dirtySettings();
            }
        }

        //! Map point under the mouse cursor
        GeoPoint getPointAtMouse(MapNode* mapNode, osg::View* v, float x, float y)
        {
            GeoPoint point;
            osg::Vec3d world;
            if (mapNode->getTerrain()->getWorldCoordsUnderMouse(v, x, y, world))
                point.fromWorld(mapNode->getMapSRS(), world);
            return point;
        }

    private:
        std::string _name;
        bool _visible;
        bool _last_visible;

    public:
        bool* visible() {
            return &_visible;
        }

        //! override to set custom values in the .ini file
        void load_base(const osgEarth::Config& conf)
        {
            conf.get("Visible", _visible);
            load(conf);
        }

        //! override to set custom values in the .ini file
        void save_base(osgEarth::Config& conf)
        {
            conf.set("Visible", _visible);
            save(conf);
        }

        //! tells ImGui it needs to write a new .ini file
        static void dirtySettings()
        {
#ifdef HAVE_IMGUI_INTERNAL
            if (ImGui::GetCurrentContext())
            {
                if (ImGui::GetCurrentWindowRead())
                {
                    ImGui::MarkIniSettingsDirty(ImGui::GetCurrentWindowRead());
                }
            }
#endif
        }

        //! whether the visibility changed (and resets the flag)
        bool visibilityChanged() {
            bool whether = _visible != _last_visible;
            _last_visible = _visible;
            return whether;
        }
    };
}




#include "LayersGUI"
#include "ContentBrowserGUI"
#include "NetworkMonitorGUI"
#include "NotifyGUI"
#include "SceneGraphGUI"
#include "TextureInspectorGUI"
#include "ViewpointsGUI"
#include "SystemGUI"
//#include "PickerGUI"
#include "EnvironmentGUI"
#include "TerrainGUI"
#include "ShaderGUI"
#include "CameraGUI"
#include "RenderingGUI"
#include "AnnotationsGUI"

#ifdef OSGEARTH_HAVE_GEOCODER
#include "SearchGUI"
#endif

#ifdef OSGEARTH_HAVE_PROCEDURAL_NODEKIT
#include <osgEarthProcedural/ImGui/LifeMapLayerGUI>
#include <osgEarthProcedural/ImGui/TerrainEditGUI>
#include <osgEarthProcedural/ImGui/TextureSplattingLayerGUI>
#include <osgEarthProcedural/ImGui/VegetationLayerGUI>
#endif

#ifdef OSGEARTH_HAVE_CESIUM_NODEKIT
#include <osgEarthCesium/ImGui/CesiumIonGUI>
#endif

#if defined(__has_include)
#if __has_include(<third_party/portable-file-dialogs/portable-file-dialogs.h>)
#include <third_party/portable-file-dialogs/portable-file-dialogs.h>
#define HAS_PFD
#endif
#endif

namespace osgEarth
{
    /**
     * ImGuiAppEngine is our own customized ImGuiEventHandler that manages a collection
     * of GUI panels and houses them in a set of menus. Several osgEarth example
     * applications and tools use this utility. You can add your own ImGuiPanel classes
     * or use the built-in ones.
     */
    class ImGuiAppEngine : public ImGuiEventHandler
    {
    public:
        using PPtr = std::shared_ptr<ImGuiPanel>;

        //! Add all the built-in GUIs
        ImGuiAppEngine(bool addBuiltIns = true)
        {
            if (addBuiltIns)
            {
                addAllBuiltInTools(nullptr);
            }
        }

        //! Add all the built-in GUIs
        ImGuiAppEngine(osg::ArgumentParser& args, bool addBuiltIns = true)
        {
            if (addBuiltIns)
            {
                addAllBuiltInTools(&args);
            }

            if (args.read("--nogui") || args.read("--no-gui"))
            {
                _show = false;
            }
        }

        template<typename T>
        T* find() {
            return dynamic_cast<T*>(reinterpret_cast<ImGuiPanel*>(findByType(typeid(T))));
        }

        //! Adds all built-in osgEarth GUI panels
        void addAllBuiltInTools(osg::ArgumentParser* args = nullptr)
        {
            _menu["Tools"].push_back(PPtr(new LayersGUI));
            _menu["Tools"].push_back(PPtr(new ViewpointsGUI));
            _menu["Tools"].push_back(PPtr(new CameraGUI));
            _menu["Tools"].push_back(PPtr(new EnvironmentGUI));
            _menu["Tools"].push_back(PPtr(new TerrainGUI));
            _menu["Tools"].push_back(PPtr(new SystemGUI));
            _menu["Tools"].push_back(PPtr(new NetworkMonitorGUI));
            _menu["Tools"].push_back(PPtr(new AnnotationsGUI()));
            _menu["Tools"].push_back(PPtr(new ContentBrowserGUI));
            //_menu["Tools"].push_back(PPtr(new NotifyGUI));
            _menu["Tools"].push_back(PPtr(new SceneGraphGUI));
            //_menu["Tools"].push_back(PPtr(new PickerGUI));
            _menu["Tools"].push_back(PPtr(new TextureInspectorGUI));
            _menu["Tools"].push_back(PPtr(new ShaderGUI(args)));
            _menu["Tools"].push_back(PPtr(new RenderingGUI()));
            _menu["Tools"].push_back(PPtr(new NVGLInspectorGUI()));

#ifdef OSGEARTH_HAVE_PROCEDURAL_NODEKIT
            _menu["Procedural"].push_back(PPtr(new osgEarth::Procedural::LifeMapLayerGUI()));
            _menu["Procedural"].push_back(PPtr(new osgEarth::Procedural::TerrainEditGUI));
            _menu["Procedural"].push_back(PPtr(new osgEarth::Procedural::TextureSplattingLayerGUI()));
            _menu["Procedural"].push_back(PPtr(new osgEarth::Procedural::VegetationLayerGUI()));
#endif

#ifdef OSGEARTH_HAVE_CESIUM_NODEKIT
            _menu["Tools"].push_back(PPtr(new osgEarth::Cesium::CesiumIonGUI()));
#endif


#ifdef OSGEARTH_HAVE_GEOCODER
            _menu["Tools"].push_back(PPtr(new SearchGUI));
#endif

            std::sort(_menu["Tools"].begin(), _menu["Tools"].end(),
                [](const PPtr& lhs, const PPtr& rhs) {
                    return std::string(lhs->name()).compare(rhs->name()) < 0;
                });
        }

        //! User adds a gui to the default User menu
        void add(ImGuiPanel* panel, bool visible = false)
        {
            OE_SOFT_ASSERT_AND_RETURN(panel, void());
            panel->setVisible(visible);
            _menu["User"].push_back(PPtr(panel));
        }

        //! User adds a gui to a named menu
        void add(const std::string& menu, ImGuiPanel* panel, bool visible = false)
        {
            OE_SOFT_ASSERT_AND_RETURN(panel, void());
            panel->setVisible(visible);
            if (menu.empty())
                add(panel, visible);
            else
                _menu[menu].push_back(PPtr(panel));
        }

        //! Find a GUI element by name
        void* findByName(const char* name) override
        {
            for (auto& iter : _menu)
                for (auto& panel : iter.second)
                    if (std::string(panel->name()).compare(name) == 0)
                        return panel.get();
            return nullptr;
        }

        //! Find a GUI element by type
        void* findByType(const std::type_info& t) override
        {
            for (auto& iter : _menu)
                for (auto& panel : iter.second)
                    if (typeid(*panel.get()) == t)
                        return panel.get();
            return nullptr;
        }

        //! Render everything
        void draw(osg::RenderInfo& ri) override
        {
            if (_showDemoWindow)
                ImGui::ShowDemoWindow();

            if (ImGui::BeginMainMenuBar())
            {
                if (ImGui::BeginMenu("File"))
                {
#ifdef HAS_PFD
                    if (ImGui::MenuItem("Open Earth File"))
                    {
                        auto f = pfd::open_file("Choose files to read", pfd::path::home(),
                            { "Earth Files", "*.earth", "All Files", "*" },
                            pfd::opt::none);

                        if (f.result().size() > 0)
                        {
                            std::string earthFile = f.result()[0];
                            osg::ref_ptr< osg::Node > node = osgDB::readRefNodeFile(earthFile);
                            if (node.valid())
                            {
                                MapNode* mapNode = MapNode::findMapNode(node);
                                osgViewer::View* view = dynamic_cast<osgViewer::View*>(ri.getView());
                                if (view && mapNode)
                                {
                                    mapNode->open();
                                    EarthManipulator* em = dynamic_cast<EarthManipulator*>(view->getCameraManipulator());
                                    if (em)
                                    {
                                        em->setNode(nullptr);
                                        em->setNode(mapNode);
                                    }
                                    view->setSceneData(mapNode);
                                }
                            }
                        }
                    }
#endif

                    ImGui::MenuItem("ImGui Demo Window", nullptr, &_showDemoWindow);

                    if (ImGui::MenuItem("Quit"))
                        exit(0);

                    ImGui::EndMenu();
                }

                for (auto& iter : _menu)
                {
                    if (ImGui::BeginMenu(iter.first.c_str()))
                    {
                        for (auto& gui : iter.second)
                        {
                            ImGui::MenuItem(gui->name(), nullptr, gui->visible());
                        }
                        ImGui::EndMenu();
                    }
                }
                ImGui::EndMainMenuBar();
            }

            bool dirty = false;

            for (auto& iter : _menu)
            {
                for (auto& gui : iter.second)
                {
                    if (gui->isVisible())
                        gui->draw(ri);

                    if (gui->visibilityChanged())
                        dirty = true;
                }
            }

            if (dirty)
                ImGuiPanel::dirtySettings();
        }

        //! Toggle a GUI's visibility by its type
        void setVisible(const std::type_info& type, bool value)
        {
            for (auto& iter : _menu)
                for (auto& gui : iter.second)
                    if (typeid(*gui.get()) == type)
                        gui->setVisible(value);
        }

        //! Toggles all GUI elements on or off
        void setAllVisible(bool value)
        {
            for (auto& iter : _menu)
                for (auto& gui : iter.second)
                    gui->setVisible(value);
        }

        void load(void* section_ptr, const std::string& key, const std::string& value) override
        {
            ImGuiPanel* gui = reinterpret_cast<ImGuiPanel*>(section_ptr);
            if (gui)
            {
                osgEarth::Config conf(gui->name());
                conf.set(key, value);
                gui->load_base(conf);
            }
        }

        void save(osgEarth::Config& conf) override
        {
            for (auto& iter : _menu)
            {
                for (auto& gui : iter.second)
                {
                    Config section(gui->name());
                    gui->save_base(section);
                    if (!section.children().empty())
                        conf.add(section);
                }
            }
        }

    protected:
        using GUIVector = std::vector<PPtr>;
        using SortedMenuMap = std::map<std::string, GUIVector>;
        SortedMenuMap _menu;
        bool _showDemoWindow = false;
    };
}
