#ifndef OSGEARTH_PROCEDURAL_VEGETATION_LAYER_GUI
#define OSGEARTH_PROCEDURAL_VEGETATION_LAYER_GUI

#include <osgEarthProcedural/Export>
#include <osgEarthProcedural/VegetationLayer>
#include <osgEarthProcedural/BiomeLayer>
#include <osgEarth/ImGui/ImGui>

namespace osgEarth {
    namespace Procedural
    {
        using namespace osgEarth;

        struct VegetationLayerGUI : public osgEarth::GUI::BaseGUI
        {
            struct PaintHandler : public osgGA::GUIEventHandler
            {
                VegetationLayerGUI* _owner;

                PaintHandler(VegetationLayerGUI* owner) :
                    _owner(owner)
                {
                }

                bool handle(const osgGA::GUIEventAdapter& ea, osgGA::GUIActionAdapter& aa)
                {
                    osgViewer::View* view = static_cast<osgViewer::View*>(aa.asView());
                    if ((ea.getButton() == ea.LEFT_MOUSE_BUTTON && ea.getEventType() == ea.PUSH) || ea.getEventType() == ea.DRAG)
                    {
                        return _owner->paintVeg(view, ea.getX(), ea.getY());
                    }                    
                    return false;
                }
            };

            bool _first;
            float _lodTransitionPixelScale;
            bool _forceGenerate;
            bool _manualBiomes;
            bool _showBiomeUnderMouse;            
            std::unordered_map<const Biome*, bool> _isManualBiomeActive;
            osg::observer_ptr<BiomeLayer> _biolayer;
            osg::observer_ptr<VegetationLayer> _veglayer;
            float _maxMaxRanges[NUM_ASSET_GROUPS];
            osg::observer_ptr<MapNode> _mapNode;
            Future<const Biome*> _biomeUnderMouse;

            bool _painting = false;
            std::string _paintAsset = "st_sugar_maple";
            bool _paintRandomAsset = false;
            float _paintMinScale = 1.0f;
            float _paintMaxScale = 1.0f;
            float _paintMinRotation = 0.0f;
            float _paintMaxRotation = 0.0f;
            osgEarth::Random _random;
            // TODO:  Get these from the biome
            const char* _assetNames[5] = { "st_sugar_maple", "st_euro_linden", "st_sugar_maple", "st_red_oak", "corn"};

            VegetationLayerGUI() : GUI::BaseGUI("Vegetation"),
                _first(true),
                _lodTransitionPixelScale(0.0f),
                _forceGenerate(false),
                _manualBiomes(false),
                _showBiomeUnderMouse(false)
            {
                //nop
            }

            void load(const Config& conf) override
            {
                conf.get("LOD_TRANSITION_PIXEL_SCALE", _lodTransitionPixelScale);
            }

            void save(Config& conf) override
            {
                conf.set("LOD_TRANSITION_PIXEL_SCALE", _lodTransitionPixelScale);
            }

            void draw(osg::RenderInfo& ri) override
            {
                if (!findNodeOrHide<MapNode>(_mapNode, ri))
                    return;
                if (!findLayerOrHide(_biolayer, ri))
                    return;
                findLayer(_veglayer, ri);

                if (_first)
                {
                    _first = false;

                    if (_veglayer.valid())
                    {
                        for (int i = 0; i < NUM_ASSET_GROUPS; ++i)
                            _maxMaxRanges[i] = _veglayer->options().groups()[i].maxRange().get() * 2.0f;
                    }

                    if (_lodTransitionPixelScale == 0.0f)
                        _lodTransitionPixelScale = _biolayer->getBiomeManager().getLODTransitionPixelScale();
                    else
                        _biolayer->getBiomeManager().setLODTransitionPixelScale(_lodTransitionPixelScale);

                    EventRouter::get(view(ri))
                        .onMove([&](osg::View* v, float x, float y) { onMove(v, x, y); });

                    auto view = dynamic_cast<osgViewer::View*>(ri.getView());
                    view->addEventHandler(new PaintHandler(this));

                    // activate tweakable uniforms
                    stateset(ri)->setDataVariance(osg::Object::DYNAMIC);
                    stateset(ri)->removeDefine("OE_TWEAKABLE");
                    stateset(ri)->setDefine("OE_TWEAKABLE", 0x7);
                }

                ImGui::Begin("Vegetation", visible());
                {
                    if (_veglayer.valid() && _veglayer->isOpen())
                    {
                        ImGui::TextColored(ImVec4(1, 1, 0, 1), "LOD scales:");
                        osg::Vec4f sse_scales = _veglayer->getSSEScales();
                        if (ImGui::SliderFloat("Near", &sse_scales[0], 0.0f, 2.0f))
                            _veglayer->setSSEScales(sse_scales);
                        if (ImGui::SliderFloat("Far", &sse_scales[1], 0.0f, 2.0f))
                            _veglayer->setSSEScales(sse_scales);

                        static float bbd0 = 0.5f, bbd1 = 0.75f;
                        ImGui::TextColored(ImVec4(1, 1, 0, 1), "Billboard cos(angles):");
                        if (ImGui::SliderFloat("Low", &bbd0, 0.0f, bbd1))
                            stateset(ri)->addUniform(new osg::Uniform("oe_veg_bbd0", bbd0));
                        if (ImGui::SliderFloat("High", &bbd1, bbd0, 1.0f))
                            stateset(ri)->addUniform(new osg::Uniform("oe_veg_bbd1", bbd1));

                        ImGui::Separator();
                        ImGui::TextColored(ImVec4(1, 1, 0, 1), "Generator:");

                        for (int i = 0; i < NUM_ASSET_GROUPS; ++i)
                        {
                            ImGui::PushID(i);

                            if (i > 0)
                                ImGui::Separator();

                            AssetGroup::Type type = (AssetGroup::Type)i;

                            ImGui::Checkbox(
                                AssetGroup::name(type).c_str(),
                                &_veglayer->options().group(type).enabled().mutable_value());

                            ImGui::SliderInt(
                                "Instances per sqkm",
                                &_veglayer->options().group(type).instancesPerSqKm().mutable_value(),
                                1024, 1024000,
                                "%d",
                                ImGuiSliderFlags_Logarithmic);

                            ImGui::PopID();
                        }

                        if (ImGui::SliderFloat("Gravity", &_veglayer->options().gravity().mutable_value(), 0.0f, 0.1f))
                            _veglayer->dirty();

                        if (ImGui::Button("Regenerate Now"))
                            _veglayer->dirty();
                    }
                    else
                    {
                        ImGui::TextColored(ImVec4(1, 0, 0, 1), "Vegetation layer is closed");
                    }

                    ImGui::Separator();

                    ImGui::Checkbox("Show biome under mouse", &_showBiomeUnderMouse);
                    if (_showBiomeUnderMouse)
                    {
                        //if (_queriedLandCover.valid())
                        //{
                        //    ImGui::Text("R=%.2f D=%.2f L=%.2f",
                        //        _queriedLandCover.rugged().get(),
                        //        _queriedLandCover.dense().get(),
                        //        _queriedLandCover.lush().get());
                        //}
                        if (_biomeUnderMouse.isWorking())
                        {
                            ImGui::Text("..searching..");
                        }
                        else if (_biomeUnderMouse.isAvailable())
                        {
                            const Biome* biome = _biomeUnderMouse.get();
                            if (biome)
                            {
                                ImGui::Text("%s", biome->name()->c_str());
                                ImGui::Text("id=%s parentid=%s index=%d",
                                    biome->id()->c_str(),
                                    biome->parentId()->c_str(),
                                    biome->index());
                            }
                            else
                            {
                                ImGui::Text("No biome");
                            }
                        }
                        else
                        {
                            ImGui::Text("No biome");
                        }
                    }

                    ImGui::Separator();

                    if (ImGui::CollapsingHeader("All Biomes"))
                    {
                        auto layer = _biolayer;
                        auto biocat = layer->getBiomeCatalog();
                        auto& bioman = layer->getBiomeManager();

                        if (ImGui::Checkbox("Select biomes manually", &_manualBiomes))
                        {
                            layer->setAutoBiomeManagement(!_manualBiomes);

                            if (_manualBiomes)
                            {
                                _isManualBiomeActive.clear();
                                for (auto biome : biocat->getBiomes())
                                    _isManualBiomeActive[biome] = false;
                            }
                            else
                            {
                                stateset(ri)->setDefine("OE_BIOME_INDEX", "-1", 0x7);
                            }
                        }

                        ImGui::Separator();

                        if (_manualBiomes)
                        {
                            for (auto biome : biocat->getBiomes())
                            {
                                ImGui::PushID(biome);
                                char buf[255];
                                sprintf(buf, "[%s] %s", biome->id()->c_str(), biome->name()->c_str());
                                if (ImGui::Checkbox(buf, &_isManualBiomeActive[biome]))
                                {
                                    if (_isManualBiomeActive[biome])
                                    {
                                        bioman.ref(biome);
                                        stateset(ri)->setDefine("OE_BIOME_INDEX", std::to_string(biome->index()), 0x7);
                                    }
                                    else
                                    {
                                        bioman.unref(biome);
                                    }
                                }
                                ImGui::PopID();
                            }
                        }
                        else
                        {
                            for (auto biome : biocat->getBiomes())
                            {
                                char buf[255];
                                sprintf(buf, "[%s] %s", biome->id()->c_str(), biome->name()->c_str());
                                ImGui::Text(buf);
                            }
                        }
                    }

                    if (ImGui::CollapsingHeader("Active Biomes", ImGuiTreeNodeFlags_DefaultOpen))
                    {
                        auto biocat = _biolayer->getBiomeCatalog();
                        auto& bioman = _biolayer->getBiomeManager();
                        auto biomes = bioman.getActiveBiomes();
                        for (auto biome : biomes)
                        {
                            char buf[255];
                            sprintf(buf, "[%s] %s", biome->id()->c_str(), biome->name()->c_str());
                            if (ImGui::TreeNode(buf))
                            {
                                for (int group = 0; group < NUM_ASSET_GROUPS; ++group)
                                {
                                    std::string groupName = group == 0 ? "Trees" : "Undergrowth";

                                    if (ImGui::TreeNode(groupName.c_str()))
                                    {
                                        for (auto& pointer : biome->getModelAssetsToUse(group))
                                        {
                                            if (ImGui::TreeNode(pointer.asset()->name()->c_str()))
                                            {
                                                drawModelAsset(pointer.asset());
                                                ImGui::TreePop();
                                            }
                                        }
                                        ImGui::TreePop();
                                    }
                                }
                                ImGui::TreePop();
                            }
                        }
                    }

                    if (ImGui::CollapsingHeader("Resident Assets", ImGuiTreeNodeFlags_DefaultOpen))
                    {
                        auto biocat = _biolayer->getBiomeCatalog();
                        auto& bioman = _biolayer->getBiomeManager();

                        auto assets = bioman.getResidentAssetsIfNotLocked();
                        for (auto& asset : assets)
                        {
                            if (ImGui::TreeNode(asset->name()->c_str()))
                            {
                                drawModelAsset(asset);
                                ImGui::TreePop();
                            }
                        }
                    }


                    ImGui::Separator();
                    ImGui::Checkbox("Paint", &_painting);                    

                    if (_painting)
                    {
                        ImGui::Checkbox("Random Asset", &_paintRandomAsset);
                        if (!_paintRandomAsset)
                        {                            
                            int item_current = 0;
                            for (int i = 0; i < IM_ARRAYSIZE(_assetNames); ++i)
                            {
                                if (_paintAsset == _assetNames[i])
                                {
                                    item_current = i;
                                    break;
                                }
                            }

                            if (ImGui::Combo("Asset", &item_current, _assetNames, IM_ARRAYSIZE(_assetNames)))
                            {
                                _paintAsset = _assetNames[item_current];
                            }
                        }

                        float scale[2] = { _paintMinScale, _paintMaxScale };
                        if (ImGui::InputFloat2("Scale Range", scale))
                        {
                            _paintMinScale = scale[0];
                            _paintMaxScale = scale[1];
                        }

                        float rot[2] = { _paintMinRotation, _paintMaxRotation };
                        if (ImGui::InputFloat2("Rotation Range", rot))
                        {
                            _paintMinRotation = rot[0];
                            _paintMaxRotation = rot[1];
                        }
                    }

                }
                ImGui::End();
            }

            void drawModelAsset(const ModelAsset* asset)
            {
                if (asset->modelURI().isSet())
                    ImGui::Text("Model: %s", asset->modelURI()->base().c_str());
                if (asset->traits().empty() == false)
                    ImGui::Text("Traits: %s", AssetTraits::toString(asset->traits()).c_str());
                if (asset->sideBillboardURI().isSet())
                    ImGui::Text("Side BB: %s", asset->sideBillboardURI()->base().c_str());
                if (asset->topBillboardURI().isSet())
                    ImGui::Text("Top BB: %s", asset->topBillboardURI()->base().c_str());
            }

            void onMove(osg::View* view, float x, float y)
            {
                if (_showBiomeUnderMouse)
                {
                    _biomeUnderMouse.reset();

                    TerrainTile* tile = _mapNode->getTerrain()->getTerrainTileUnderMouse(view, x, y);
                    if (tile)
                    {
                        GeoPoint p = _mapNode->getGeoPointUnderMouse(view, x, y);
                        TileKey key = _mapNode->getMap()->getProfile()->createTileKey(p.x(), p.y(), tile->getKey().getLOD());
                        key = _biolayer->getBestAvailableTileKey(key, false);
                            
                        if (key.valid())
                        {
                            _biomeUnderMouse = Job().dispatch<const Biome*>([&, key, p](Cancelable* c)
                                {
                                    const Biome* result = nullptr;
                                    osg::ref_ptr<ProgressCallback> prog = new ProgressCallback(c);
                                    auto g = _biolayer->createImage(key, prog.get());
                                    if (g.valid())
                                    {
                                        GeoImage::pixel_type pixel;
                                        g.getReader().setBilinear(false);
                                        g.read(pixel, p);
                                        int biome_index = (int)pixel.r();
                                        result = _biolayer->getBiomeCatalog()->getBiomeByIndex(biome_index);
                                    }
                                    return result;
                                });
                        }
                    }
                }
            }

            bool paintVeg(osg::View* view, float x, float y)
            {
                if (*visible() && _painting)
                {
                    GeoPoint p = _mapNode->getGeoPointUnderMouse(view, x, y);
                    if (p.isValid())
                    {
                        VegetationLayer::VegetationInstance i;
                        i.location = p;
                        if (_paintRandomAsset)
                        {
                            unsigned int numAssets = IM_ARRAYSIZE(_assetNames);
                            unsigned int index = _random.next(4);
                            i.assetName = _assetNames[index];
                        }
                        else
                        {
                            i.assetName = _paintAsset;
                        }
                        i.scale = _paintMinScale + _random.next() * (_paintMaxScale - _paintMinScale);
                        i.rotation = osg::DegreesToRadians(_paintMinRotation + _random.next() * (_paintMaxRotation - _paintMinRotation));
                        _veglayer->addVegetationInstance(i);
                        _veglayer->dirty();
                        return true;
                    }
                }
                return false;
            }
        };
    }
}
#endif // OSGEARTH_PROCEDURAL_VEGETATION_LAYER_GUI

//REGISTER_OSGEARTH_IMGUI(VegetationLayer, []()
//    {
//        return new osgEarth::Procedural::VegetationLayerGUI();
//    }
//)
