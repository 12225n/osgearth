/* -*-c++-*- */
/* osgEarth - Geospatial SDK for OpenSceneGraph
 * Copyright 2018 Pelican Mapping
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */
#ifndef OSGEARTH_FEATURES_TFS_FEATURESOURCE_LAYER
#define OSGEARTH_FEATURES_TFS_FEATURESOURCE_LAYER

#include <osgEarthFeatures/FeatureSource>
#include <osgEarth/GeoData>

using namespace osgEarth;
using namespace osgEarth::Features;
using namespace osgEarth::Symbology;

namespace osgDB {
    class Options;
}

/**
 * TFS API
 */
namespace osgEarth { namespace Features { namespace TFS
{    
    class OSGEARTHFEATURES_EXPORT Layer
    {
    public:
        Layer();

        const std::string& getTitle() const { return _title;}
        void setTitle(const std::string& value) { _title = value;}

        const std::string& getAbstract() const { return _abstract;}
        void setAbstract(const std::string& value) { _abstract = value;}

        const GeoExtent& getExtent() const { return _extent;}
        void setExtent(const GeoExtent& value) { _extent = value;}

        unsigned int getMaxLevel() const { return _maxLevel;}
        void setMaxLevel( unsigned int value ) { _maxLevel = value;}

        unsigned int getFirstLevel() const { return _firstLevel;}
        void setFirstLevel(unsigned int value) { _firstLevel = value;}

        const SpatialReference* getSRS() const { return _srs.get();}
        void setSRS( const SpatialReference* srs ) { _srs = srs;}

    private:
        std::string _title;
        std::string _abstract;
        GeoExtent _extent;
        unsigned int _maxLevel;
        unsigned int _firstLevel;
        osg::ref_ptr< const SpatialReference > _srs;
    };

    class OSGEARTHFEATURES_EXPORT ReaderWriter
    {
    public:
        static bool read(const URI& uri, const osgDB::Options* options, Layer& layer);
        static bool read( std::istream& in, Layer& layer);

        static void write(const Layer& layer, const std::string& location);
        static void write(const Layer& layer, std::ostream& output);
    };

}}} // namespace osgEarth::Features::TFS


/**
 * A FeatureSource that reads feature tiles from a TFS layer
 */
namespace osgEarth { namespace Features
{
    /**
     * Serialization data for the TFS feature source
     */
    class OSGEARTHFEATURES_EXPORT TFSFeatureSourceOptions : public FeatureSourceOptions
    {
    public:
        META_LayerOptions(osgEarth, TFSFeatureSourceOptions, FeatureSourceOptions);

        //! TFS endpoint location
        optional<URI>& url() { return _url; }
        const optional<URI>& url() const { return _url; }
                
        //! Data format extension of TFS data (json, gml)
        optional<std::string>& format() { return _format; }
        const optional<std::string>& format() const { return _format; }        

        optional<bool>& invertY() { return _invertY; }
        const optional<bool>& invertY() const { return _invertY; }

        optional<int>& minLevel() { return _minLevel; }
        const optional<int>& minLevel() const { return _minLevel; }

        optional<int>& maxLevel() { return _maxLevel; }
        const optional<int>& maxLevel() const { return _maxLevel; }
    public:
        virtual Config getConfig() const;

    private:
        void fromConfig(const Config& conf);
        optional<URI>         _url;        
        optional<std::string> _format;
        optional<bool>        _invertY;
        optional<int>         _minLevel;
        optional<int>         _maxLevel;
    };

    /**
     * Feature Layer that accesses features from a TFS endpoint
     */
    class OSGEARTHFEATURES_EXPORT TFSFeatureSource : public FeatureSource
    {   
    public:
        META_Layer(osgEarth, TFSFeatureSource, TFSFeatureSourceOptions, FeatureSource, tfsfeatures);

    public:

    public: // Layer

        virtual const Status& open();

    protected:

        virtual void init();

    public: // FeatureLayer

        virtual FeatureCursor* createFeatureCursor(const Symbology::Query& query, ProgressCallback* progress);        
        
        virtual const FeatureSchema& getSchema() const { return _schema; }

    protected:

        virtual ~TFSFeatureSource() { }

    private:    
        FeatureSchema _schema;       
        TFS::Layer _layer;
        bool _layerValid;

        bool getFeatures(const std::string& buffer, const TileKey& key, const std::string& mimeType, FeatureList& features);
        std::string getExtensionForMimeType(const std::string& mime);
        bool isGML(const std::string& mime) const;
        bool isJSON(const std::string& mime) const;
        std::string createURL(const Symbology::Query& query);
    };

} } // namespace osgEarth::Features

OSGEARTH_SPECIALIZE_CONFIG(osgEarth::Features::TFSFeatureSourceOptions);

#endif // OSGEARTH_FEATURES_TFS_FEATURESOURCE_LAYER
