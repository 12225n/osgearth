/* -*-c++-*- */
/* osgEarth - Geospatial SDK for OpenSceneGraph
* Copyright 2020 Pelican Mapping
* http://osgearth.org
*
* osgEarth is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>
*/
#ifndef OSGEARTH_CHONK
#define OSGEARTH_CHONK 1

#include <osgEarth/Common>
#include <osgEarth/GLUtils>
#include <osgEarth/TextureArena>
#include <vector>
#include <unordered_set>

namespace osgEarth
{
    class OSGEARTH_EXPORT ChonkMaterial
    {
    public:
        using Ptr = std::shared_ptr<ChonkMaterial>;
        static Ptr create();

        int albedo;

    private:
        ChonkMaterial() : albedo(-1) { }
    };

    /**
     * A bindless drawable.
     */
    class OSGEARTH_EXPORT Chonk
    {
    public:
        struct VertexGPU
        {
            osg::Vec3f position;
            osg::Vec3f normal;
            osg::Vec4ub color;
            osg::Vec2f uv;
            GLint albedo; // TODO: upgrade to material index
        };
        /*
        struct VertexGPU
        {
            vec3 position;
            vec3 normal;
            unorm32 color;
            vec2 uv;
            short albedo;
        };
        */

    public:
        using Ptr = std::shared_ptr<Chonk>;
        static Ptr create();

        using Command = DrawElementsIndirectBindlessCommandNV;

        std::vector<ChonkMaterial::Ptr> _materials; // todo: upgrade to material index
        std::vector<VertexGPU> _vbo_store;
        std::vector<GLushort> _ebo_store;

        struct GCState
        {
            GLBuffer::Ptr vbo;
            GLBuffer::Ptr ebo;
            DrawElementsIndirectBindlessCommandNV command;
        };
        mutable osg::buffered_object<GCState> _gs;
        
        //! Gets (or creates) a draw command, possibly
        //! resolving texture handles and uploading buffers.
        const Command& getOrCreateCommand(osg::State&) const;

    private:
        Chonk();
    };

    /**
     * Creates Chonks.
     */
    class OSGEARTH_EXPORT ChonkFactory
    {
    public:
        ChonkFactory(
            TextureArena* textures);

        //! Adds a node and generates an asset drawable for it.
        //! The asset will upload to the GPU on the next call to apply.
        Chonk::Ptr create(osg::Node* node);

        //! Removes a drawable.
        void remove(Chonk::Ptr);

        const std::vector<Chonk::Ptr>& getChonks() const {
            return _chonks;
        }

    private:
        std::vector<Chonk::Ptr> _chonks;
        osg::ref_ptr<TextureArena> _textures;
    };

    /**
     * Test class to render a Chonk.
     */
    class OSGEARTH_EXPORT ChonkDrawable : public osg::Drawable
    {
    public:
        ChonkDrawable();

        osg::BoundingSphere computeBound() const override {
            return osg::BoundingSphere(getBoundingBox());
        };
        osg::BoundingBox computeBoundingBox() const override {
            return osg::BoundingBox({ -50,-50,-50,50,50,50 });
        };

        //! Adds a chonk to the drawable.
        void add(Chonk::Ptr value);

    public:

        virtual void drawImplementation(osg::RenderInfo& ri) const override;
        virtual void resizeGLObjectBuffers(unsigned) override;
        virtual void releaseGLObjects(osg::State*) const override;

    protected:
        virtual ~ChonkDrawable() { }

        mutable Mutex _m;
        std::vector<Chonk::Ptr> _chonks;

        struct GCState
        {
            unsigned _numCommands;
            GLBuffer::Ptr _commandBuf;
            GLVAO::Ptr _vao;
            bool _dirty;
            void(GL_APIENTRY * _glMultiDrawElementsIndirectBindlessNV)
                (GLenum, GLenum, const GLvoid*, GLsizei, GLsizei, GLint);
                
            GCState() : _vao(0), _dirty(true) { }
            void update(const std::vector<Chonk::Ptr>&, osg::State&);
            void draw(osg::State& state);
            void release();
            GLVAO::Ptr createAndRecordVAO(osg::State& state);
        };
        mutable osg::buffered_object<GCState> _gs;

    };
}

#endif // OSGEARTH_INSTANCE_CLOUD
