/* --*-c++-*-- */
/* osgEarth - Geospatial SDK for OpenSceneGraph
 * Copyright 2020 Pelican Mapping
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */

#ifndef OSGEARTH_TILED_FEATURE_MODEL_GRAPH_H
#define OSGEARTH_TILED_FEATURE_MODEL_GRAPH_H 1

#include <osgEarth/Common>
#include <osgEarth/FeatureSource>
#include <osgEarth/FeatureSourceIndexNode>
#include <osgEarth/Style>
#include <osgEarth/SimplePager>
#include <osgEarth/MapNode>
#include <osgEarth/StyleSheet>
#include <osgEarth/Registry>
#include <osgEarth/AnnotationUtils>
#include <osg/ShapeDrawable>
#include <osgDB/ReadFile>
#include <osg/MatrixTransform>
#include <osgUtil/Simplifier>
#include <osgEarth/ElevationQuery>

namespace osgEarth {

    class OSGEARTH_EXPORT NodeGraphResult
    {
    public:
        NodeGraphResult()
        {
        }

        NodeGraphResult(osg::Node* node):
            nodeValue(node)
        {
        }

        NodeGraphResult(float value) :
            floatValue(value)
        {
        }

        NodeGraphResult(FeatureList value) :
            featuresValue(value)
        {
        }

        float floatValue;
        osg::ref_ptr< osg::Node > nodeValue;
        FeatureList featuresValue;
    };

    // Socket or Pin is maybe a better name?
    class NodeAttribute
    {
    public:

        enum AttributeType
        {
            NODE,
            FLOAT,
            STRING,
            FEATURES
        };

        NodeAttribute(const std::string& name, AttributeType type) :
            _name(name),
            _type(type)
        {
            static std::atomic<int> atomic_id{ 0 };
            _id = atomic_id.fetch_add(1);
        }

        int getId() const { return _id; }
        const std::string& getName() const {
            return _name;
        }

        AttributeType getType() const {
            return _type;
        }
        

    private:
        int _id;
        std::string _name;
        AttributeType _type;
    };

    class NodeGraphOperation;

    class OSGEARTH_EXPORT Link
    {
    public:
        Link(NodeGraphOperation* source, const NodeAttribute* sourceAttribute,
            NodeGraphOperation* destination, const NodeAttribute* destinationAttribute):
            _source(source),
            _sourceAttribute(sourceAttribute),
            _destination(destination),
            _destinationAttribute(destinationAttribute)
        {
            static std::atomic<int> atomic_id{ 0 };
            _id = atomic_id.fetch_add(1);
        }

        const int getId() const {
            return _id;
        }

        NodeGraphOperation* _source;
        const NodeAttribute* _sourceAttribute;

        NodeGraphOperation* _destination;
        const NodeAttribute* _destinationAttribute;

        int _id;
    };


    class OSGEARTH_EXPORT NodeGraphContext
    {
    public:
        osgEarth::TileKey tileKey;
        const Map* map;
    };

    class OSGEARTH_EXPORT NodeGraphOperation
    {
    public:
        NodeGraphOperation()
        {
            static std::atomic<int> atomic_id{ 0 };
            _id = atomic_id.fetch_add(1);
        }

        virtual void execute(const NodeGraphContext& context) = 0;

        int getId() const { return _id; }

        bool ready() const {
            return _ready;
        }

        const std::string& getName() const {
            return _name;
        }

        void setName(const std::string& name)
        {
            _name = name;
        }

        // Connect an output pin of one node to an input pin on this Operation
        void connect(const std::string& outputName, NodeGraphOperation* destination, const std::string& destinationName)
        {
            auto output = getOutputAttribute(outputName);
            auto input = destination->getInputAttribute(destinationName);
            _links.push_back(Link(this, output, destination, input));
        }

        NodeGraphResult* get_input(const std::string& name)
        {
            auto itr = _inputs.find(name);
            if (itr != _inputs.end())
            {
                return &itr->second;
            }
            return nullptr;
        }

        void set_output(const std::string& name, osg::Node* node)
        {
            _outputs[name] = node;
            for (auto &l : _links)
            {
                if (l._sourceAttribute->getName() == name)
                {
                    l._destination->set_input(l._destinationAttribute->getName(), node);                    
                }
            }
        }

        void set_output(const std::string& name, float value)
        {
            _outputs[name] = value;
            for (auto& l : _links)
            {
                if (l._sourceAttribute->getName() == name)
                {
                    l._destination->set_input(l._destinationAttribute->getName(), value);
                }
            }
        }

        void set_output(const std::string& name, FeatureList& value)
        {
            _outputs[name] = value;
            for (auto& l : _links)
            {
                if (l._sourceAttribute->getName() == name)
                {
                    l._destination->set_input(l._destinationAttribute->getName(), value);
                }
            }
        }

        void set_input(const std::string& name, osg::Node* node)
        {
            _inputs[name] = node;
            _ready = false;
        }

        void set_input(const std::string& name, float value)
        {
            _inputs[name] = value;
            _ready = false;
        }

        void set_input(const std::string& name, FeatureList& features)
        {
            _inputs[name] = features;
            _ready = false;
        }

        virtual void reset()
        {
            _inputs.clear();
            _outputs.clear();
            _dependencies.clear();
            _ready = false;
        }

        const std::vector< NodeAttribute >& getInputAttributes() const
        {
            return _inputAttributes;
        }

        const NodeAttribute* getInputAttribute(const std::string& name) const
        {
            for (auto& i : _inputAttributes)
            {
                if (i.getName() == name) return &i;
            }
            return nullptr;
        }

        const NodeAttribute* getOutputAttribute(const std::string& name) const
        {
            for (auto& i : _outputAttributes)
            {
                if (i.getName() == name) return &i;
            }
            return nullptr;
        }

        const std::vector< NodeAttribute >& getOutputAttributes() const
        {
            return _outputAttributes;
        }

        const std::vector< Link >& getLinks() const {
            return _links;
        }

        std::vector< Link >& getLinks() {
            return _links;
        }

        void addDependency(NodeGraphOperation* dep)
        {
            _dependencies.insert(dep);
        }

        void executeWithDependencies(const NodeGraphContext& context)
        {
            // Execute all the dependencies first
            for (auto& d : _dependencies)
            {
                d->executeWithDependencies(context);
            }

            // Execute this operation
            execute(context);
        }

    protected:
        void addInputAttribute(const std::string& name, NodeAttribute::AttributeType type)
        {
            _inputAttributes.emplace_back(name, type);
        }

        void addOutputAttribute(const std::string& name, NodeAttribute::AttributeType type)
        {
            _outputAttributes.emplace_back(name, type);
        }

        std::map< std::string, NodeGraphResult > _inputs;
        std::map< std::string, NodeGraphResult > _outputs;

        std::vector< NodeAttribute > _inputAttributes;
        std::vector< NodeAttribute > _outputAttributes;

        std::vector< Link > _links;

        std::set< NodeGraphOperation* > _dependencies;

        bool _ready = false;

        std::string _name;

        int _id;
    };    

    class OSGEARTH_EXPORT FloatValue : public NodeGraphOperation
    {
    public:
        FloatValue()
        {
            _name = "Float";
            addOutputAttribute("Value", NodeAttribute::FLOAT);
        }

        virtual void execute(const NodeGraphContext& context)
        {
            set_output("Value", _value);
            _ready = true;
        }

        float getValue() const { return _value; }
        void setValue(float value) { _value = value; }

        float _value = 0.0f;
    };


    class OSGEARTH_EXPORT SphereOperation : public NodeGraphOperation
    {
    public:
        SphereOperation()
        {
            _name = "Sphere";

            addInputAttribute("Radius", NodeAttribute::FLOAT);
            addOutputAttribute("Node", NodeAttribute::NODE);
        }

        virtual void execute(const NodeGraphContext& context) override
        {
            /*
            osg::Geode* geode = new osg::Geode;
            osg::ShapeDrawable* sd = new osg::ShapeDrawable(new osg::Sphere(osg::Vec3f(0, 0, 0), _radius));
            sd->setColor(_color);
            geode->addDrawable(sd);
            setOutput(geode);
            */
            //setOutput(AnnotationUtils::createSphere(_radius, _color));

            auto radius = get_input("Radius");
            if (radius)
            {
                if (radius->floatValue > 0)
                {
                    set_output("Node", AnnotationUtils::createSphere(radius->floatValue, _color));
                    _ready = true;
                }
            }
        }

        //float getRadius() const { return _radius; }
        //void setRadius(float radius) { _radius = radius; }

        const osg::Vec4& getColor() const { return _color; }
        void setColor(osg::Vec4& color) { _color = color; }

        //float _radius = 1000.0f;
        osg::Vec4 _color = osg::Vec4f(1.0f, 0.0f, 0.0f, 1.0f);
    };

    class OSGEARTH_EXPORT LoadNodeOperation : public NodeGraphOperation
    {
    public:
        LoadNodeOperation()
        {
            _name = "Load Node";
            addOutputAttribute("Node", NodeAttribute::NODE);
        }

        LoadNodeOperation(const std::string& filename)
        {
            _name = filename;
            _filename = filename;
            addOutputAttribute("Node", NodeAttribute::NODE);
        }

        virtual void execute(const NodeGraphContext& context) override
        {
            std::lock_guard<std::mutex> lk(_mutex);
            if (!_loaded.valid())
            {
                _loaded = osgDB::readNodeFile(_filename);
                osgEarth::Registry::instance()->shaderGenerator().run(_loaded.get());
            }
            // Need to consider where to clone geometry, who knows if the node is going to be mucked with later on down the chain.  Who's responsibility should that be?
            //set_output("Node", (osg::Node*)_loaded->clone(osg::CopyOp::DEEP_COPY_ALL));
            set_output("Node", _loaded.get());
            _ready = true;
        }

        std::string getFilename() const { return _filename; }
        void setFilename(const std::string& filename) { _filename = filename; }

        std::string _filename;

        osg::ref_ptr< osg::Node > _loaded;
        std::mutex _mutex;
    };

    class OSGEARTH_EXPORT TransformOperation : public NodeGraphOperation
    {
    public:
        TransformOperation()
        {
            _name = "Transform";
            addInputAttribute("Node", NodeAttribute::NODE);
            addOutputAttribute("Node", NodeAttribute::NODE);
        }

        virtual void execute(const NodeGraphContext& context) override
        {
            auto nodeInput = get_input("Node");
            if (nodeInput)
            {
                osg::MatrixTransform* mt = new osg::MatrixTransform;
                mt->setMatrix(_transform);
                mt->addChild(nodeInput->nodeValue.get());
                set_output("Node", mt);
                _ready = true;
            }
        }

        const osg::Matrix& getTransform() const { return _transform; }
        void setTransform(const osg::Matrix& transform) { _transform = transform; }

        osg::Matrix _transform;
    };

    class OSGEARTH_EXPORT SimplifyOperation : public NodeGraphOperation
    {
    public:
        SimplifyOperation()
        {
            _name = "Simplify";
            addInputAttribute("Node", NodeAttribute::NODE);
            addOutputAttribute("Node", NodeAttribute::NODE);
        }

        void setSampleRatio(float sampleRatio) { _sampleRatio = sampleRatio; }
        float getSampleRatio() const { return _sampleRatio; }

        void setMaximumError(float error) { _maximumError = error; }
        float getMaximumError() const { return _maximumError; }

        void setMaximumLength(float length) { _maximumLength = length; }
        float getMaximumLength() const { return _maximumLength; }

        void setSmoothing(bool on) { _smoothing = on; }
        bool getSmoothing() const { return _smoothing; }

        virtual void execute(const NodeGraphContext& context) override
        {           
            auto nodeInput = get_input("Node");
            if (nodeInput)
            {
                // We are going to be modifying this node, so clone it before we make changes to the geometry
                osg::ref_ptr< osg::Node > cloned = (osg::Node*)nodeInput->nodeValue->clone(osg::CopyOp::DEEP_COPY_ALL);

                osgUtil::Simplifier simp(_sampleRatio, _maximumError, _maximumLength);
                simp.setSmoothing(_smoothing);
                simp.setDoTriStrip(false);

                cloned->accept(simp);

                set_output("Node", cloned.get());
                _ready = true;
            }
        }


        float _maximumLength = 0.0f;
        float _maximumError = 5000.0;
        float _sampleRatio = 1.0f;
        bool _smoothing = true;

    };


    class OSGEARTH_EXPORT JoinNodesOperation : public NodeGraphOperation
    {
    public:
        JoinNodesOperation()
        {
            _name = "Join Nodes";
            addInputAttribute("Node1", NodeAttribute::NODE);
            addInputAttribute("Node2", NodeAttribute::NODE);
            addInputAttribute("Node3", NodeAttribute::NODE);

            addOutputAttribute("Node", NodeAttribute::NODE);
        }

        virtual void execute(const NodeGraphContext& context) override
        {
            // TODO:  The randomly going over the nodes isn't going to work
            // we need some dependency graph and need to do them in order.
            auto node1 = get_input("Node1");
            auto node2 = get_input("Node2");
            auto node3 = get_input("Node3");

            if (node1 || node2 || node3)
            {
                osg::Group* result = new osg::Group;
                if (node1) result->addChild(node1->nodeValue.get());
                if (node2) result->addChild(node2->nodeValue.get());
                if (node3) result->addChild(node3->nodeValue.get());
                set_output("Node", result);
                _ready = true;
            }
        }
    };

    class OSGEARTH_EXPORT RandomPointsOperation : public NodeGraphOperation
    {
    public:
        RandomPointsOperation()
        {
            _name = "Random Points";

            addOutputAttribute("Points", NodeAttribute::FEATURES);
        }

        virtual void execute(const NodeGraphContext& context) override
        {
            FeatureList features;

            auto extent = context.tileKey.getExtent();

            for (unsigned int i = 0; i < _count; ++i)
            {
                PointSet* p = new PointSet;
                double x = extent.xMin() + _prng.next() * extent.width();
                double y = extent.yMin() + _prng.next() * extent.height();

                p->push_back(osg::Vec3d(x, y, 0));
                Feature* f = new Feature(p, context.tileKey.getProfile()->getSRS());
                features.push_back(f);
            }

            set_output("Points", features);
            _ready = true;
        }

        unsigned int getCount() const
        {
            return _count;
        }

        void setCount(unsigned int count)
        {
            _count = count;
        }

        unsigned int _count = 10;
        Random   _prng;
    };


    class OSGEARTH_EXPORT PointsOnEdgeOperation : public NodeGraphOperation
    {
    public:
        PointsOnEdgeOperation()
        {
            _name = "Points on Edge";

            addOutputAttribute("Points", NodeAttribute::FEATURES);
        }

        virtual void execute(const NodeGraphContext& context) override
        {
            FeatureList features;

            auto extent = context.tileKey.getExtent();

            double width = extent.width();
            double height = extent.height();
            double dx = width / (double)_count;
            double dy = height / (double)_count;

            // Left edge
            double x = extent.xMin();
            double y = extent.yMin();            
            for (unsigned int i = 0; i < _count; ++i)
            {
                PointSet* p = new PointSet;                
                p->push_back(osg::Vec3d(x, y, 0));
                Feature* f = new Feature(p, context.tileKey.getProfile()->getSRS());
                features.push_back(f);
                y += dy;
            }

            // Right edge
            x = extent.xMax();
            y = extent.yMin();            
            for (unsigned int i = 0; i < _count; ++i)
            {
                PointSet* p = new PointSet;
                p->push_back(osg::Vec3d(x, y, 0));
                Feature* f = new Feature(p, context.tileKey.getProfile()->getSRS());
                features.push_back(f);
                y += dy;
            }

            // Top edge
            x = extent.xMin();
            y = extent.yMax();
            for (unsigned int i = 0; i < _count; ++i)
            {
                PointSet* p = new PointSet;
                p->push_back(osg::Vec3d(x, y, 0));
                Feature* f = new Feature(p, context.tileKey.getProfile()->getSRS());
                features.push_back(f);
                x += dx;
            }

            // Bottom edge
            x = extent.xMin();
            y = extent.yMin();
            for (unsigned int i = 0; i < _count; ++i)
            {
                PointSet* p = new PointSet;
                p->push_back(osg::Vec3d(x, y, 0));
                Feature* f = new Feature(p, context.tileKey.getProfile()->getSRS());
                features.push_back(f);
                x += dx;
            }

            set_output("Points", features);
            _ready = true;
        }

        unsigned int getCount() const
        {
            return _count;
        }

        void setCount(unsigned int count)
        {
            _count = count;
        }

        unsigned int _count = 10;
    };


    class OSGEARTH_EXPORT ClampPointsOperation : public NodeGraphOperation
    {
    public:
        ClampPointsOperation()
        {
            _name = "Clamp Points";

            addInputAttribute("Points", NodeAttribute::FEATURES);
            addOutputAttribute("Points", NodeAttribute::FEATURES);
        }

        virtual void execute(const NodeGraphContext& context) override
        {
            auto points = get_input("Points");
            if (points)
            {
                osgEarth::Util::ElevationQuery eq(context.map);

                for (auto& f : points->featuresValue)
                {
                    GeometryIterator itr(f->getGeometry());
                    while (itr.hasMore())
                    {
                        Geometry* g = itr.next();
                        for (Geometry::iterator v = g->begin(); v != g->end(); ++v)
                        {                            
                            double x = v->x();
                            double y = v->y();
                            double z = v->z();

                            GeoPoint pt(f->getSRS(), x, y, z);
                            z = eq.getElevation(pt);
                            v->z() = z;                            
                        }
                    }
                }
                // These are modified in place, this is faster but is destructive to the features from the input
                set_output("Points", points->featuresValue);
            }            
        }

        unsigned int getCount() const
        {
            return _count;
        }

        void setCount(unsigned int count)
        {
            _count = count;
        }

        unsigned int _count = 10;
        Random   _prng;
    };


    class OSGEARTH_EXPORT CurrentLODOperation : public NodeGraphOperation
    {
    public:
        CurrentLODOperation()
        {
            _name = "Current LOD";
            addOutputAttribute("LOD", NodeAttribute::FLOAT);
        }

        virtual void execute(const NodeGraphContext& context) override
        {
            set_output("LOD", context.tileKey.getLevelOfDetail());            
            _ready = true;
        }
    };

    class OSGEARTH_EXPORT ComparisonOperator : public NodeGraphOperation
    {
    public:

        enum Comparison
        {
            GREATER_THAN,
            GREATER_THAN_EQUAL,
            LESS_THAN,
            LESS_THAN_EQUAL,
            EQUAL
        };

        ComparisonOperator()
        {
            _name = "Comparison";

            addInputAttribute("Node", NodeAttribute::NODE);
            addInputAttribute("A", NodeAttribute::FLOAT);
            addInputAttribute("B", NodeAttribute::FLOAT);

            addOutputAttribute("Passed", NodeAttribute::NODE);
            addOutputAttribute("Failed", NodeAttribute::NODE);
        }

        virtual void execute(const NodeGraphContext& context) override
        {
            auto node = get_input("Node");
            auto a = get_input("A");
            auto b = get_input("B");

            if (node && a && b)
            {
                bool passed = false;
                switch (_comparison)
                {
                case GREATER_THAN:
                    passed = a->floatValue > b->floatValue;
                    break;
                case GREATER_THAN_EQUAL:
                    passed = a->floatValue >= b->floatValue;
                    break;
                case LESS_THAN:
                    passed = a->floatValue < b->floatValue;
                    break;
                case LESS_THAN_EQUAL:
                    passed = a->floatValue <= b->floatValue;
                    break;
                case EQUAL:
                    passed = a->floatValue == b->floatValue;
                    break;
                default:
                    break;
                }

                if (passed)
                {
                    set_output("Passed", node->nodeValue);
                }
                else
                {
                    set_output("Failed", node->nodeValue);
                }
                _ready = true;
            }
        }

        const Comparison getComparison() const
        {
            return _comparison;
        }

        void setComparison(Comparison comparison)
        {
            _comparison = comparison;
        }

        Comparison _comparison;
    };


    class OSGEARTH_EXPORT PlaceNodesOperation : public NodeGraphOperation
    {
    public:
        PlaceNodesOperation()
        {
            _name = "Place Nodes";
            addInputAttribute("Points", NodeAttribute::FEATURES);
            addInputAttribute("Node", NodeAttribute::NODE);

            addOutputAttribute("Node", NodeAttribute::NODE);
        }

        virtual void execute(const NodeGraphContext& context) override
        {
            auto node = get_input("Node");
            auto points = get_input("Points");

            if (node && points)
            {                
                osg::Matrixd w2l;
                context.tileKey.getExtent().getCentroid().createWorldToLocal(w2l);    

                osg::Group* result = new osg::Group;

                // We know the tile is already going to be localized so don't do it twice.
                for (auto& f : points->featuresValue)
                {
                    GeometryIterator itr(f->getGeometry());
                    while (itr.hasMore())
                    {
                        Geometry* g = itr.next();
                        for (Geometry::const_iterator v = g->begin(); v != g->end(); ++v)
                        {
                            double x = v->x();
                            double y = v->y();
                            double z = v->z();

                            float scale = _minScale + _prng.next() * (_maxScale - _minScale);

                            GeoPoint pt(f->getSRS(), x, y, z);
                            osg::Vec3d world;
                            pt.toWorld(world);

                            float heading = _minHeading + _prng.next() * (_maxHeading - _minHeading);
                            osg::Vec3d local = world * w2l;
                            osg::MatrixTransform* mt = new osg::MatrixTransform;
                            osg::Quat rotation = osg::Quat(osg::DegreesToRadians(heading), osg::Vec3(0, 0, 1));
                            //mt->setMatrix(osg::Matrixd::translate(local));
                            mt->setMatrix(osg::Matrixd::scale(scale, scale, scale) *
                                osg::Matrix::rotate(rotation) *
                                osg::Matrix::translate(local));
                            mt->addChild(node->nodeValue.get());
                            result->addChild(mt);
                        }
                    }
                }

                set_output("Node", result);
                _ready = true;
            }
        }

        float getMinScale() const
        {
            return _minScale;
        }

        void setMinScale(float minScale)
        {
            _minScale = minScale;
        }

        float getMaxScale() const
        {
            return _maxScale;
        }

        void setMaxScale(float maxScale)
        {
            _maxScale = maxScale;
        }

        float getMinHeading() const
        {
            return _minHeading;
        }

        void setMinHeading(float minHeading)
        {
            _minHeading = minHeading;
        }

        float getMaxHeading() const
        {
            return _maxHeading;
        }

        void setMaxHeading(float maxHeading)
        {
            _maxHeading = maxHeading;
        }


    private:
        float _minScale = 1.0f;
        float _maxScale = 1.0f;
        float _minHeading = 0.0f;
        float _maxHeading= 0.0f;
        Random   _prng;
    };

    class OSGEARTH_EXPORT NodeOutputOperation : public NodeGraphOperation
    {
    public:
        NodeOutputOperation()
        {
            _name = "Node Output";
            addInputAttribute("Node", NodeAttribute::NODE);
        }

        virtual void execute(const NodeGraphContext& context) override
        {
            auto i = get_input("Node");
            if (i)
            {
                result = i->nodeValue.get();
                _ready = true;
            }
        }

        // Clear out the "result".  This should probably be an output instead of a variable?
        virtual void reset()
        {
            NodeGraphOperation::reset();
            result = nullptr;
        }

        osg::ref_ptr< osg::Node > result;
    };

    class OSGEARTH_EXPORT NodeGraph
    {
    public:
        virtual void execute(const NodeGraphContext& context)
        {
            // The NodeGraph can be ran multiple times during threaded loading for each load.  Maybe it needs cloned or something for reach
            // execution
            // Lock it for now.     
            std::lock_guard< std::mutex > lk(_mutex);

            NodeOutputOperation* outputNode = nullptr;
            // First reset all the operations and find the output node.
            for (auto& op : operations)
            {
                op->reset();

                if (!outputNode)
                {
                    outputNode = dynamic_cast<NodeOutputOperation*>(op.get());
                }
            }

            if (!outputNode)
            {
                OE_NOTICE << "No NodeOutputOperation found" << std::endl;
                return;
            }


            // Build the dependencies.  We could do this at connect/disconnect time instead but this should be fast enough.
            for (auto &op : operations)
            {
                for (auto& link : op->getLinks())
                {
                    // Add a dependency for the destination
                    link._destination->addDependency(op.get());
                }
            }

            // Execute only the output node with it's dependencies
            outputNode->executeWithDependencies(context);

            // In theory there is a final node now.
            _output = outputNode->result.get();

        }

        std::vector< std::shared_ptr< NodeGraphOperation > > operations;

        osg::Node* getOutput() const { return _output.get(); }
        osg::ref_ptr < osg::Node > _output;

        std::mutex _mutex;        
    };


    class OSGEARTH_EXPORT NodeGraphNode : public osg::MatrixTransform
    {
    public:
        NodeGraphNode()
        {
        }

        void build()
        {
            removeChildren(0, getNumChildren());
            NodeGraphContext context;
            context.tileKey = _tileKey;
            context.map = _map;
            _nodeGraph->execute(context);

            if (_nodeGraph->getOutput())
            {
                addChild(_nodeGraph->getOutput());
            }
        }

        TileKey _tileKey;
        const Map* _map;
        std::shared_ptr< NodeGraph > _nodeGraph;
    };



    /**
     * A scene graph node that renders tiled feature data.
     */
    class OSGEARTH_EXPORT TiledFeatureModelGraph : public SimplePager
    {
    public:
        TiledFeatureModelGraph(const osgEarth::Map* map,
                               FeatureSource* features,
                               StyleSheet* styleSheet,
                               Session* session);

        //! Sets an optional feature filter collection
        void setFilterChain(FeatureFilterChain* chain);

        void setOwnerName(const std::string& value);

        std::shared_ptr< NodeGraph > getNodeGraph() { return _nodeGraph; }
        void setNodeGraph(std::shared_ptr< NodeGraph> nodeGraph)
        {
            if (_nodeGraph != nodeGraph)
            {
                _nodeGraph = nodeGraph;
                dirtyNodeGraph();
            }
        }

        void dirtyNodeGraph()
        {
            unsigned int i = 0;
            std::lock_guard< std::mutex> lk(_nodesMutex);
            for (auto n : _nodes)
            {
                OE_NOTICE << "Building " << i++ << " of " << _nodes.size() << " nodes" << std::endl;
                osg::ref_ptr< NodeGraphNode> ng;
                if (n.lock(ng))
                {
                    ng->_nodeGraph = _nodeGraph;
                    ng->build();
                }
            }
        }


        void registerNode(NodeGraphNode* node)
        {
            std::lock_guard< std::mutex> lk(_nodesMutex);
            _nodes.push_back(node);
        }

        std::mutex _nodesMutex;
        std::vector< osg::observer_ptr< NodeGraphNode > > _nodes;

    public: // SimplePager

        virtual osg::ref_ptr<osg::Node> createNode(const TileKey& key, ProgressCallback* progress) override;

    private:

        std::shared_ptr< NodeGraph > _nodeGraph;

        osg::ref_ptr < FeatureSource > _features;
        osg::ref_ptr< StyleSheet > _styleSheet;
        osg::ref_ptr< Session > _session;
        osg::ref_ptr< FeatureFilterChain > _filterChain;
        std::string _ownerName;
        
        osg::ref_ptr<FeatureSourceIndex> _featureIndex;       


        FeatureCursor* createCursor(FeatureSource* fs, FilterContext& cx, const Query& query, ProgressCallback* progress) const;
    };
}

#endif // OSGEARTH_TILED_FEATURE_MODEL_GRAPH_H
