/* -*-c++-*- */
/* osgEarth - Geospatial SDK for OpenSceneGraph
 * Copyright 2018 Pelican Mapping
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */
#ifndef OSGEARTH_IMGUI_MAP_LAYERS_GUI
#define OSGEARTH_IMGUI_MAP_LAYERS_GUI

#include <osgEarth/MapNode>
#include <osgEarth/EarthManipulator>
#include <osgEarth/ViewFitter>
#include <osgEarth/ThreeDTilesLayer>
#include <osgEarth/ImageLayer>
#include <osg/Camera>

namespace osgEarth {
    namespace GUI
    {
        using namespace osgEarth;
        using namespace osgEarth::Contrib;
        using namespace osgEarth::Util;

        class LayersGUI
        {
        public:
            LayersGUI()
            {
            }

            void draw(osg::RenderInfo& renderInfo, osgEarth::MapNode* mapNode, osg::Camera* camera, EarthManipulator* manip)
            {
                ImGui::Begin("Layers");

                osgEarth::VisibleLayerVector layers;
                mapNode->getMap()->getLayers(layers);

                for (int i = layers.size() - 1; i >= 0; --i)
                {
                    osgEarth::Layer* layer = layers[i].get();
                    ImGui::PushID(layer);
                    osgEarth::VisibleLayer *visibleLayer = dynamic_cast<osgEarth::VisibleLayer*>(layer);
                    if (visibleLayer)
                    {
                        bool visible = visibleLayer->getVisible();
                        ImGui::Checkbox(layer->getName().c_str(), &visible);
                        visibleLayer->setVisible(visible);
                    }
                    else
                    {
                        ImGui::Text(layer->getName().c_str());
                    }

                    ImGui::SameLine();
                    if (i > 0)
                    {
                        if (ImGui::ArrowButton("down", ImGuiDir_Down))
                        {
                            mapNode->getMap()->moveLayer(layer, i - 1);
                        }
                    }
                    if (i < layers.size() - 1)
                    {
                        ImGui::SameLine();
                        if (ImGui::ArrowButton("up", ImGuiDir_Up))
                        {
                            mapNode->getMap()->moveLayer(layer, i + 1);
                        }
                    }

                    ImGui::SameLine();
                    if (ImGui::ArrowButton("right", ImGuiDir_Right))
                    {
                        const GeoExtent& extent = layer->getExtent();
                        if (extent.isValid())
                        {
                            std::vector<GeoPoint> points;
                            points.push_back(GeoPoint(extent.getSRS(), extent.west(), extent.south()));
                            points.push_back(GeoPoint(extent.getSRS(), extent.east(), extent.north()));

                            ViewFitter fitter(mapNode->getMap()->getSRS(), camera);
                            Viewpoint vp;
                            if (fitter.createViewpoint(points, vp))
                            {
                                manip->setViewpoint(vp, 2.0);
                            }
                        }
                        else if (layer->getNode())
                        {
                            const osg::BoundingSphere& bs = layer->getNode()->getBound();
                            if (bs.valid())
                            {
                                osg::Vec3d c = bs.center();
                                double r = bs.radius();
                                const SpatialReference* mapSRS = mapNode->getMap()->getSRS();

                                std::vector<GeoPoint> points;
                                GeoPoint p;
                                p.fromWorld(mapSRS, osg::Vec3d(c.x() + r, c.y(), c.z())); points.push_back(p);
                                p.fromWorld(mapSRS, osg::Vec3d(c.x() - r, c.y(), c.z())); points.push_back(p);
                                p.fromWorld(mapSRS, osg::Vec3d(c.x(), c.y() + r, c.z())); points.push_back(p);
                                p.fromWorld(mapSRS, osg::Vec3d(c.x(), c.y() - r, c.z())); points.push_back(p);
                                p.fromWorld(mapSRS, osg::Vec3d(c.x(), c.y(), c.z() + r)); points.push_back(p);
                                p.fromWorld(mapSRS, osg::Vec3d(c.x(), c.y(), c.z() - r)); points.push_back(p);

                                ViewFitter fitter(mapNode->getMap()->getSRS(), camera);
                                Viewpoint vp;
                                if (fitter.createViewpoint(points, vp))
                                {
                                    manip->setViewpoint(vp, 2.0);
                                }
                            }
                        }
                    }

                    osgEarth::ImageLayer* imageLayer = dynamic_cast<osgEarth::ImageLayer*>(visibleLayer);
                    if (imageLayer)
                    {
                        float opacity = imageLayer->getOpacity();
                        ImGui::PushID("opacity");
                        ImGui::SliderFloat("Opacity", &opacity, 0.0f, 1.0f);
                        imageLayer->setOpacity(opacity);
                        ImGui::PopID();
                    }

                    osgEarth::Contrib::ThreeDTilesLayer* threedTiles = dynamic_cast<osgEarth::Contrib::ThreeDTilesLayer*>(visibleLayer);
                    if (threedTiles)
                    {
                        float sse = threedTiles->getMaximumScreenSpaceError();
                        ImGui::PushID("sse");
                        ImGui::SliderFloat("SSE", &sse, 0.0f, 50.0f);
                        threedTiles->setMaximumScreenSpaceError(sse);
                        ImGui::PopID();

                        ImGui::PushID("debugVolumes");
                        bool showBoundingVolumes = threedTiles->getTilesetNode()->getShowBoundingVolumes();
                        ImGui::Checkbox("Show debug volumes", &showBoundingVolumes);
                        threedTiles->getTilesetNode()->setShowBoundingVolumes(showBoundingVolumes);
                        ImGui::PopID();

                        ImGui::PushID("debugColors");
                        bool colorPerTile = threedTiles->getTilesetNode()->getColorPerTile();
                        ImGui::Checkbox("Show color per tile", &colorPerTile);
                        threedTiles->getTilesetNode()->setColorPerTile(colorPerTile);
                        ImGui::PopID();
                    }
                    ImGui::PopID();

                    ImGui::Separator();
                }
                ImGui::End();
            }

            bool _showLog;
            bool _showNetworkMonitor;
            bool _showTextureInspector;
            bool _showSceneHierarchy;
            //LogGUI _log;
            //NetworkMonitorGUI _networkMonitor;
            //SearchGUI _searchGUI;
            //TextureInspectorGUI _textureInspectorGUI;
            //SceneHierarchy _sceneHierarchy;

            std::vector< Viewpoint > _viewpoints;
            bool _scannedForViewpoints = false;
        };
    }
}

#endif // OSGEARTH_IMGUI_MAP_LAYERS_GUI
