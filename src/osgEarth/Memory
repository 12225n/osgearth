/* -*-c++-*- */
/* osgEarth - Geospatial SDK for OpenSceneGraph
* Copyright 2020 Pelican Mapping
* http://osgearth.org
*
* osgEarth is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>
*/
#pragma once

#include <osgEarth/Common>
#include <cstdint>
#include <cstdlib>
#include <new>
#include <mutex>
#include <unordered_map>
#include <limits>
#include <iostream>

namespace osgEarth { namespace Util
{
    struct AllocatorData
    {
        std::mutex mutex;
        std::size_t max_freelist_size = 64;
        std::size_t news = 0;
        std::size_t recycles = 0;

        struct Block
        {
            std::size_t size;
            std::list<void*> freelist;
        };
        std::vector<Block> blocks;

        Block& get_or_create_block(std::size_t size)
        {
            for (auto& block : blocks) {
                if (block.size == size)
                    return block;
            }
            blocks.emplace_back(Block{ size });
            return blocks.back();
        }
    };

    class OSGEARTH_EXPORT Memory
    {
    public:
        /** Physical memory usage, in bytes, for the calling process. (aka working set or resident set) */
        static std::int64_t getProcessPhysicalUsage();

        /** Peak physical memory usage, in bytes, for the calling process since it started. */
        static std::int64_t getProcessPeakPhysicalUsage();

        /** Private bytes allocated solely to this process */
        static std::int64_t getProcessPrivateUsage();

        /** Maximum bytes allocated privately to thie process (peak pagefile usage) */
        static std::int64_t getProcessPeakPrivateUsage();

        static AllocatorData& allocator();

    private:
        // Not creatable.
        Memory() { }
    };

    template<typename T>
    struct PooledAllocator // : public PooledAllocatorBase
    {
        using value_type = T;

        PooledAllocator() = default;

        template<class U>
        constexpr PooledAllocator(const PooledAllocator<U>& rhs) noexcept { }

        T* allocate(std::size_t n)
        {
            if (n > std::numeric_limits<std::size_t>::max() / sizeof(T))
                throw std::bad_array_new_length();

            std::lock_guard<std::mutex> lock(Memory::allocator().mutex);

            auto bytes = n * sizeof(T);
            auto& block = Memory::allocator().get_or_create_block(bytes);
            
            if (block.freelist.empty())
            {
                if (auto ptr = static_cast<T*>(std::malloc(bytes)))
                {
                    ++Memory::allocator().news;
                    return ptr;
                }
                throw std::bad_alloc();
            }
            else
            {
                T* ptr = static_cast<T*>(block.freelist.front());
                block.freelist.pop_front();
                ++Memory::allocator().recycles;
                return ptr;
            }
        }

        void deallocate(T* ptr, std::size_t n) noexcept
        {
            std::lock_guard<std::mutex> lock(Memory::allocator().mutex);

            auto& block = Memory::allocator().get_or_create_block(n * sizeof(T));
            if (block.freelist.size() >= Memory::allocator().max_freelist_size)
            {
                std::free(ptr);
            }
            else
            {
                block.freelist.push_back(ptr);
            }
        }
    };
} }

