/* -*-c++-*- */
/* osgEarth - Geospatial SDK for OpenSceneGraph
 * Copyright 2018 Pelican Mapping
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */
#pragma once

#include <osgEarthImGui/ImGuiEventHandler>
#include <osgEarthImGui/LayersGUI>
#include <osgEarthImGui/ContentBrowserGUI>
#include <osgEarthImGui/NetworkMonitorGUI>
#include <osgEarthImGui/NotifyGUI>
#include <osgEarthImGui/SceneGraphGUI>
#include <osgEarthImGui/TextureInspectorGUI>
#include <osgEarthImGui/ViewpointsGUI>
#include <osgEarthImGui/SystemGUI>
#include <osgEarthImGui/EnvironmentGUI>
#include <osgEarthImGui/TerrainGUI>
#include <osgEarthImGui/ShaderGUI>
#include <osgEarthImGui/CameraGUI>
#include <osgEarthImGui/RenderingGUI>
#include <osgEarthImGui/AnnotationsGUI>
#include <osgEarthImGui/PickerGUI>

#ifdef OSGEARTH_HAVE_GEOCODER
#include <osgEarthImGui/SearchGUI>
#endif

#ifdef OSGEARTH_HAVE_PROCEDURAL_NODEKIT
#include <osgEarthImGui/LifeMapLayerGUI>
#include <osgEarthImGui/TerrainEditGUI>
#include <osgEarthImGui/TextureSplattingLayerGUI>
#include <osgEarthImGui/VegetationLayerGUI>
#endif

#ifdef OSGEARTH_HAVE_CESIUM_NODEKIT
#include <osgEarthCesium/ImGui/CesiumIonGUI>
#endif

#if defined(__has_include)
#if __has_include(<third_party/portable-file-dialogs/portable-file-dialogs.h>)
#include <third_party/portable-file-dialogs/portable-file-dialogs.h>
#define HAS_PFD
#endif
#endif

namespace osgEarth
{
    /**
     * ImGuiAppEngine is our own customized ImGuiEventHandler that manages a collection
     * of GUI panels and houses them in a set of menus. Several osgEarth example
     * applications and tools use this utility. You can add your own ImGuiPanel classes
     * or use the built-in ones.
     */
    class ImGuiAppEngine : public ImGuiEventHandler // no export
    {
    public:
        using PPtr = std::shared_ptr<ImGuiPanel>;

        //! Add all the built-in GUIs
        ImGuiAppEngine(bool addBuiltIns = true)
        {
            if (addBuiltIns)
            {
                addAllBuiltInTools(nullptr);
            }
        }

        //! Add all the built-in GUIs
        ImGuiAppEngine(osg::ArgumentParser& args, bool addBuiltIns = true)
        {
            if (addBuiltIns)
            {
                addAllBuiltInTools(&args);
            }

            if (args.read("--nogui") || args.read("--no-gui"))
            {
                _show = false;
            }
        }

        template<typename T>
        T* find() {
            return dynamic_cast<T*>(reinterpret_cast<ImGuiPanel*>(findByType(typeid(T))));
        }

        //! Adds all built-in osgEarth GUI panels
        void addAllBuiltInTools(osg::ArgumentParser* args = nullptr)
        {
            _menu["Tools"].push_back(PPtr(new LayersGUI));
            _menu["Tools"].push_back(PPtr(new ViewpointsGUI));
            _menu["Tools"].push_back(PPtr(new CameraGUI));
            _menu["Tools"].push_back(PPtr(new EnvironmentGUI));
            _menu["Tools"].push_back(PPtr(new TerrainGUI));
            _menu["Tools"].push_back(PPtr(new SystemGUI));
            _menu["Tools"].push_back(PPtr(new NetworkMonitorGUI));
            _menu["Tools"].push_back(PPtr(new AnnotationsGUI()));
            _menu["Tools"].push_back(PPtr(new ContentBrowserGUI));
            //_menu["Tools"].push_back(PPtr(new NotifyGUI));
            _menu["Tools"].push_back(PPtr(new SceneGraphGUI));
            _menu["Tools"].push_back(PPtr(new PickerGUI));
            _menu["Tools"].push_back(PPtr(new TextureInspectorGUI));
            _menu["Tools"].push_back(PPtr(new ShaderGUI(args)));
            _menu["Tools"].push_back(PPtr(new RenderingGUI()));
            _menu["Tools"].push_back(PPtr(new NVGLInspectorGUI()));

#ifdef OSGEARTH_HAVE_PROCEDURAL_NODEKIT
            _menu["Procedural"].push_back(PPtr(new osgEarth::Procedural::LifeMapLayerGUI()));
            _menu["Procedural"].push_back(PPtr(new osgEarth::Procedural::TerrainEditGUI));
            _menu["Procedural"].push_back(PPtr(new osgEarth::Procedural::TextureSplattingLayerGUI()));
            _menu["Procedural"].push_back(PPtr(new osgEarth::Procedural::VegetationLayerGUI()));
#endif

#ifdef OSGEARTH_HAVE_CESIUM_NODEKIT
            _menu["Tools"].push_back(PPtr(new osgEarth::Cesium::CesiumIonGUI()));
#endif


#ifdef OSGEARTH_HAVE_GEOCODER
            _menu["Tools"].push_back(PPtr(new SearchGUI));
#endif

            std::sort(_menu["Tools"].begin(), _menu["Tools"].end(),
                [](const PPtr& lhs, const PPtr& rhs) {
                    return std::string(lhs->name()).compare(rhs->name()) < 0;
                });
        }

        //! User adds a gui to the default User menu
        void add(ImGuiPanel* panel, bool visible = false)
        {
            OE_SOFT_ASSERT_AND_RETURN(panel, void());
            panel->setVisible(visible);
            _menu["User"].push_back(PPtr(panel));
        }

        //! User adds a gui to a named menu
        void add(const std::string& menu, ImGuiPanel* panel, bool visible = false)
        {
            OE_SOFT_ASSERT_AND_RETURN(panel, void());
            panel->setVisible(visible);
            if (menu.empty())
                add(panel, visible);
            else
                _menu[menu].push_back(PPtr(panel));
        }

        //! Find a GUI element by name
        void* findByName(const char* name) override
        {
            for (auto& iter : _menu)
                for (auto& panel : iter.second)
                    if (std::string(panel->name()).compare(name) == 0)
                        return panel.get();
            return nullptr;
        }

        //! Find a GUI element by type
        void* findByType(const std::type_info& t) override
        {
            for (auto& iter : _menu)
                for (auto& panel : iter.second)
                    if (typeid(*panel.get()) == t)
                        return panel.get();
            return nullptr;
        }

        //! Render everything
        void draw(osg::RenderInfo& ri) override
        {
            if (_showDemoWindow)
                ImGui::ShowDemoWindow();

            if (ImGui::BeginMainMenuBar())
            {
                if (ImGui::BeginMenu("File"))
                {
#ifdef HAS_PFD
                    if (ImGui::MenuItem("Open Earth File"))
                    {
                        auto f = pfd::open_file("Choose files to read", pfd::path::home(),
                            { "Earth Files", "*.earth", "All Files", "*" },
                            pfd::opt::none);

                        if (f.result().size() > 0)
                        {
                            std::string earthFile = f.result()[0];
                            osg::ref_ptr< osg::Node > node = osgDB::readRefNodeFile(earthFile);
                            if (node.valid())
                            {
                                MapNode* mapNode = MapNode::findMapNode(node);
                                osgViewer::View* view = dynamic_cast<osgViewer::View*>(ri.getView());
                                if (view && mapNode)
                                {
                                    mapNode->open();
                                    EarthManipulator* em = dynamic_cast<EarthManipulator*>(view->getCameraManipulator());
                                    if (em)
                                    {
                                        em->setNode(nullptr);
                                        em->setNode(mapNode);
                                    }
                                    view->setSceneData(mapNode);
                                }
                            }
                        }
                    }
#endif

                    ImGui::MenuItem("ImGui Demo Window", nullptr, &_showDemoWindow);

                    if (ImGui::MenuItem("Quit"))
                        exit(0);

                    ImGui::EndMenu();
                }

                for (auto& iter : _menu)
                {
                    if (ImGui::BeginMenu(iter.first.c_str()))
                    {
                        for (auto& gui : iter.second)
                        {
                            ImGui::MenuItem(gui->name(), nullptr, gui->visible());
                        }
                        ImGui::EndMenu();
                    }
                }
                ImGui::EndMainMenuBar();
            }

            bool dirty = false;

            for (auto& iter : _menu)
            {
                for (auto& gui : iter.second)
                {
                    if (gui->isVisible())
                        gui->draw(ri);

                    if (gui->visibilityChanged())
                        dirty = true;
                }
            }

            if (dirty)
                ImGuiPanel::dirtySettings();
        }

        //! Toggle a GUI's visibility by its type
        void setVisible(const std::type_info& type, bool value)
        {
            for (auto& iter : _menu)
                for (auto& gui : iter.second)
                    if (typeid(*gui.get()) == type)
                        gui->setVisible(value);
        }

        //! Toggles all GUI elements on or off
        void setAllVisible(bool value)
        {
            for (auto& iter : _menu)
                for (auto& gui : iter.second)
                    gui->setVisible(value);
        }

        void load(void* section_ptr, const std::string& key, const std::string& value) override
        {
            ImGuiPanel* gui = reinterpret_cast<ImGuiPanel*>(section_ptr);
            if (gui)
            {
                osgEarth::Config conf(gui->name());
                conf.set(key, value);
                gui->load_base(conf);
            }
        }

        void save(osgEarth::Config& conf) override
        {
            for (auto& iter : _menu)
            {
                for (auto& gui : iter.second)
                {
                    Config section(gui->name());
                    gui->save_base(section);
                    if (!section.children().empty())
                        conf.add(section);
                }
            }
        }

    protected:
        using GUIVector = std::vector<PPtr>;
        using SortedMenuMap = std::map<std::string, GUIVector>;
        SortedMenuMap _menu;
        bool _showDemoWindow = false;
    };
}
