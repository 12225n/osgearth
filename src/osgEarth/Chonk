/* -*-c++-*- */
/* osgEarth - Geospatial SDK for OpenSceneGraph
* Copyright 2020 Pelican Mapping
* http://osgearth.org
*
* osgEarth is free software; you can redistribute it and/or modify
* it under the terms of the GNU Lesser General Public License as published by
* the Free Software Foundation; either version 2 of the License, or
* (at your option) any later version.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*
* You should have received a copy of the GNU Lesser General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>
*/
#ifndef OSGEARTH_CHONK
#define OSGEARTH_CHONK 1

#include <osgEarth/Common>
#include <osgEarth/GLUtils>
#include <osgEarth/TextureArena>
#include <vector>
#include <unordered_set>

namespace osgEarth
{
    class OSGEARTH_EXPORT ChonkMaterial
    {
    public:
        using Ptr = std::shared_ptr<ChonkMaterial>;
        static Ptr create();

        int albedo;

    private:
        ChonkMaterial() : albedo(-1) { }
    };

    class ChonkFactory;

    /**
     * A bindless drawable.
     */
    class OSGEARTH_EXPORT Chonk
    {
    public:
        //! Adds a node.
        bool add(
            osg::Node*,
            ChonkFactory& factory);

        //! Adds a node with pixel size limits.
        bool add(
            osg::Node* node,
            float min_pixel_size,
            float max_pixel_size,
            ChonkFactory& factory);

        const osg::BoundingBoxf& getBound();

    public:
        //! Single vertex in the drawable
        struct VertexGPU
        {
            osg::Vec3f position;
            osg::Vec3f normal;
            osg::Vec4ub color;
            osg::Vec2f uv;
            GLint albedo; // TODO: upgrade to material index
        };

        //! Geometry variant for a given pixel size range
        struct Variant
        {
            unsigned offset;
            std::size_t length;
            float minPixelSize;
            float maxPixelSize;
        };

    public:
        using Ptr = std::shared_ptr<Chonk>;
        static Ptr create();

        std::vector<ChonkMaterial::Ptr> _materials; // todo: upgrade to material index
        std::vector<VertexGPU> _vbo_store;
        std::vector<GLushort> _ebo_store;
        std::vector<Variant> _variants;
        osg::BoundingBoxf _box;

        // Customed draw command
        using DrawCommand = DrawElementsIndirectBindlessCommandNV;
        using DrawCommands = std::vector<DrawCommand>;

        struct GCState
        {
            GLBuffer::Ptr vbo;
            GLBuffer::Ptr ebo;
            DrawCommands commands;
        };
        mutable osg::buffered_object<GCState> _gs;
        
        //! Gets (or creates) a draw command, possibly
        //! resolving texture handles and uploading buffers.
        const DrawCommands& getOrCreateCommands(osg::State&) const;

    private:
        Chonk();
        friend class ChonkFactory;
        friend class ChonkDrawable;
    };

    /**
     * Creates Chonks.
     */
    class OSGEARTH_EXPORT ChonkFactory
    {
    public:
        ChonkFactory(
            TextureArena* textures);

        //! Adds a node and generates an asset drawable for it.
        //! The asset will upload to the GPU on the next call to apply.
        void load(
            osg::Node* node,
            Chonk& chonk);

    private:
        osg::ref_ptr<TextureArena> _textures;
    };

    /**
     * Class to render a Chonk.
     */
    class OSGEARTH_EXPORT ChonkDrawable : public osg::Drawable
    {
    public:
        ChonkDrawable();

        //! Adds a chonk to the drawable.
        void add(Chonk::Ptr value);

        void add(Chonk::Ptr value, const osg::Matrixf& xform);

    public:

        // todo - call whn the cull program is active
        //void cull(osg::RenderInfo& ri) const;

    public:

        virtual osg::BoundingBox computeBoundingBox() const override;
        virtual void drawImplementation(osg::RenderInfo& ri) const override;
        virtual void resizeGLObjectBuffers(unsigned) override;
        virtual void releaseGLObjects(osg::State*) const override;

    protected:
        virtual ~ChonkDrawable() { }

        mutable Mutex _m;

        struct Instance
        {
            osg::Matrixf xform;
            GLuint first_variant_cmd_index;
            GLuint visible_mask;
            GLfloat _padding[2];
        };
        using Instances = std::vector<Instance>;
        using Batches = std::unordered_map<Chonk::Ptr, Instances>;
        Batches _batches;

        struct ChonkVariant
        {
            osg::Vec3f center;
            GLfloat radius;
            GLfloat min_pixel_size;
            GLfloat max_pixel_size;
            GLuint num_variants;
            GLuint total_num_commands;
        };

        struct GCState
        {
            std::vector<Chonk::DrawCommand> _commands;
            std::size_t _numInstances;
            std::size_t _maxNumVariants;
            GLBuffer::Ptr _commandBuf;
            GLBuffer::Ptr _instanceInputBuf;
            GLBuffer::Ptr _instanceOutputBuf;
            GLBuffer::Ptr _chonkBuf;
            GLint _passUL;
            GLVAO::Ptr _vao;
            bool _dirty;
            bool _cull;
            void(GL_APIENTRY * _glMultiDrawElementsIndirectBindlessNV)
                (GLenum, GLenum, const GLvoid*, GLsizei, GLsizei, GLint);
                
            GCState() : _dirty(true), _cull(true), _passUL(-1) { }
            void initialize(osg::State& state);
            void update(const Batches&, osg::State&);
            void cull(osg::State& state);
            void draw(osg::State& state);
            void release();

            osg::ref_ptr<osg::Program> _cullProgram;
            osg::ref_ptr<osg::StateSet> _cullSS;
        };
        mutable osg::buffered_object<GCState> _gs;

    };
}

#endif // OSGEARTH_INSTANCE_CLOUD
