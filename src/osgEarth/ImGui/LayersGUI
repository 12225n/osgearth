/* -*-c++-*- */
/* osgEarth - Geospatial SDK for OpenSceneGraph
 * Copyright 2018 Pelican Mapping
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */
#ifndef OSGEARTH_IMGUI_MAP_LAYERS_GUI
#define OSGEARTH_IMGUI_MAP_LAYERS_GUI

#include "ImGui"
#include <osgEarth/MapNode>
#include <osgEarth/EarthManipulator>
#include <osgEarth/ViewFitter>
#include <osgEarth/ThreeDTilesLayer>
#include <osgEarth/ImageLayer>
#include <osgEarth/NodeUtils>
#include <osg/Camera>

namespace osgEarth {
    namespace GUI
    {
        using namespace osgEarth;
        using namespace osgEarth::Contrib;
        using namespace osgEarth::Util;

        class LayersGUI : public BaseGUI
        {
        private:
            osg::ref_ptr<MapNode> _mapNode;

        public:
            LayersGUI() :
                BaseGUI("Map Layers")
            {
            }

            void draw(osg::RenderInfo& ri) override
            {
                if (!isVisible())
                    return;

                osg::Camera* camera = ri.getCurrentCamera();
                osgViewer::View* view = dynamic_cast<osgViewer::View*>(camera->getView());

                if (!_mapNode.valid())
                    _mapNode = osgEarth::findTopMostNodeOfType<MapNode>(camera);

                ImGui::Begin(name(), visible());

                osgEarth::VisibleLayerVector layers;
                _mapNode->getMap()->getLayers(layers);

                for (int i = layers.size() - 1; i >= 0; --i)
                {
                    osgEarth::Layer* layer = layers[i].get();
                    ImGui::PushID(layer);

                    bool error = !layer->isOpen();
                    if (error)
                        ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(ImColor(255, 72, 72)));

                    osgEarth::VisibleLayer* visibleLayer = dynamic_cast<osgEarth::VisibleLayer*>(layer);
                    if (visibleLayer)
                    {
                        bool isopen = layer->isOpen();
                        ImGui::Checkbox("", &isopen);
                        if (isopen)
                            visibleLayer->open();
                        else
                            visibleLayer->close();

#if 0
                        bool visible = visibleLayer->getVisible();
                        ImGui::Checkbox("", &visible);
                        //ImGui::Checkbox(layer->getName().c_str(), &visible);
                        visibleLayer->setVisible(visible);
#endif

                        ImGui::SameLine();

                        bool selected = false;
                        ImGui::Selectable(layer->getName().c_str(), &selected);
                        if (selected)
                        {
                            const GeoExtent& extent = layer->getExtent();
                            if (extent.isValid())
                            {
                                std::vector<GeoPoint> points;
                                points.push_back(GeoPoint(extent.getSRS(), extent.west(), extent.south()));
                                points.push_back(GeoPoint(extent.getSRS(), extent.east(), extent.north()));

                                ViewFitter fitter(_mapNode->getMap()->getSRS(), camera);
                                Viewpoint vp;
                                if (fitter.createViewpoint(points, vp))
                                {
                                    auto manip = dynamic_cast<EarthManipulator*>(view->getCameraManipulator());
                                    manip->setViewpoint(vp, 2.0);
                                }
                            }
                            else if (layer->getNode())
                            {
                                const osg::BoundingSphere& bs = layer->getNode()->getBound();
                                if (bs.valid())
                                {
                                    osg::Vec3d c = bs.center();
                                    double r = bs.radius();
                                    const SpatialReference* mapSRS = _mapNode->getMap()->getSRS();

                                    std::vector<GeoPoint> points;
                                    GeoPoint p;
                                    p.fromWorld(mapSRS, osg::Vec3d(c.x() + r, c.y(), c.z())); points.push_back(p);
                                    p.fromWorld(mapSRS, osg::Vec3d(c.x() - r, c.y(), c.z())); points.push_back(p);
                                    p.fromWorld(mapSRS, osg::Vec3d(c.x(), c.y() + r, c.z())); points.push_back(p);
                                    p.fromWorld(mapSRS, osg::Vec3d(c.x(), c.y() - r, c.z())); points.push_back(p);
                                    p.fromWorld(mapSRS, osg::Vec3d(c.x(), c.y(), c.z() + r)); points.push_back(p);
                                    p.fromWorld(mapSRS, osg::Vec3d(c.x(), c.y(), c.z() - r)); points.push_back(p);

                                    ViewFitter fitter(_mapNode->getMap()->getSRS(), camera);
                                    Viewpoint vp;
                                    if (fitter.createViewpoint(points, vp))
                                    {
                                        auto manip = dynamic_cast<EarthManipulator*>(view->getCameraManipulator());
                                        manip->setViewpoint(vp, 2.0);
                                    }
                                }
                            }
                        }
                    }
                    else
                    {
                        ImGui::Text(layer->getName().c_str());
                    }

                    if (layer->isOpen())
                    {
                        osgEarth::ImageLayer* imageLayer = dynamic_cast<osgEarth::ImageLayer*>(visibleLayer);
                        if (visibleLayer)
                        {
                            ImGui::Indent();
                            float opacity = visibleLayer->getOpacity();
                            ImGui::PushID("opacity");
                            ImGui::SliderFloat("Opacity", &opacity, 0.0f, 1.0f);
                            visibleLayer->setOpacity(opacity);
                            ImGui::PopID();
                            ImGui::Unindent();
                        }

                        osgEarth::Contrib::ThreeDTilesLayer* threedTiles = dynamic_cast<osgEarth::Contrib::ThreeDTilesLayer*>(visibleLayer);
                        if (threedTiles)
                        {
                            ImGui::Indent();

                            float sse = threedTiles->getMaximumScreenSpaceError();
                            ImGui::PushID("sse");
                            ImGui::SliderFloat("SSE", &sse, 0.0f, 50.0f);
                            threedTiles->setMaximumScreenSpaceError(sse);
                            ImGui::PopID();

                            ImGui::PushID("debugVolumes");
                            bool showBoundingVolumes = threedTiles->getTilesetNode()->getShowBoundingVolumes();
                            ImGui::Checkbox("Show debug volumes", &showBoundingVolumes);
                            threedTiles->getTilesetNode()->setShowBoundingVolumes(showBoundingVolumes);
                            ImGui::PopID();

                            ImGui::PushID("debugColors");
                            bool colorPerTile = threedTiles->getTilesetNode()->getColorPerTile();
                            ImGui::Checkbox("Show color per tile", &colorPerTile);
                            threedTiles->getTilesetNode()->setColorPerTile(colorPerTile);
                            ImGui::PopID();

                            ImGui::Unindent();
                        }
                    }  

                    ImGui::PopID();

                    if (error)
                        ImGui::PopStyleColor(1);

                    ImGui::Separator();
                }

                ImGui::End();
            }
        };
    }
}

#endif // OSGEARTH_IMGUI_MAP_LAYERS_GUI
