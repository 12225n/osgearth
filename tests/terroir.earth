<map>
    <libraries>osgEarthSplat</libraries>

    <TMSElevation name="ReadyMap 90m Elevation">
        <url>http://readymap.org/readymap/tiles/1.0.0/116/</url>
        <vdatum>egm96</vdatum>
    </TMSElevation>

    <xi:include href="viewpoints.xml"/>

    <xi:include href="land_cover_dictionary.xml"/>

    <Viewpoints>
        <viewpoint>
            <heading>31.3108</heading>
            <pitch>-1.00964</pitch>
            <range>121.972m</range>
            <long>-121.990158956114</long>
            <lat>46.92703494048406</lat>
            <height>804.4625725736842</height>
            <srs>+proj=longlat +datum=WGS84 +no_defs </srs>
        </viewpoint>
        <viewpoint name="Roadside in America">
            <heading>-104.704</heading>
            <pitch>-5.53409</pitch>
            <range>34.1453m</range>
            <long>-88.98736153822145</long>
            <lat>33.44677645652552</lat>
            <height>67.96329618152231</height>
            <srs>+proj=longlat +datum=WGS84 +no_defs </srs>
        </viewpoint>
        <viewpoint name="Sahara Desert">
            <heading>19.1486</heading>
            <pitch>-5.47115</pitch>
            <range>1579.82m</range>
            <long>5.532673035060111</long>
            <lat>24.4095608331511</lat>
            <height>1670.410200586542</height>
            <srs>+proj=longlat +datum=WGS84 +no_defs </srs>
        </viewpoint>
        <viewpoint>
            <heading>4.78372</heading>
            <pitch>-12.8643</pitch>
            <range>871.642m</range>
            <long>86.70992701098108</long>
            <lat>27.80425932879971</lat>
            <height>3412.017050028779</height>
            <srs>+proj=longlat +datum=WGS84 +no_defs </srs>
        </viewpoint>
        <viewpoint>
            <heading>-120.932</heading>
            <pitch>-19.8311</pitch>
            <range>2529.82m</range>
            <long>-113.6306600515501</long>
            <lat>35.74415839165609</lat>
            <height>1141.220891861245</height>
            <srs>+proj=longlat +datum=WGS84 +no_defs </srs>
        </viewpoint>
        <viewpoint>
            <heading>-100.934</heading>
            <pitch>-18.2287</pitch>
            <range>44.0949m</range>
            <long>-113.6400863942717</long>
            <lat>35.7373749129136</lat>
            <height>1396.437415332533</height>
            <srs>+proj=longlat +datum=WGS84 +no_defs </srs>
        </viewpoint>
    </Viewpoints>

    <mbtileselevation name="Nepal" enabled="false">
        <url>D:/data/demo/nepal/nepal.mbtiles</url>
    </mbtileselevation>

    <GroundCover name="Trees" max_range="7500" max_sse="100">
        <xi:include href="../data/splat/trees/groundcover.xml"/>
        <cast_shadows>true</cast_shadows>
        <mask_layer>OSM MASK</mask_layer>
    </GroundCover>

    <Grass name="Grass" max_range="100" max_sse="10">
        <xi:include href="../data/splat/grass/groundcover.xml"/>
        <mask_layer>OSM MASK</mask_layer>
    </Grass>

    <Wind name="Breeze">
        <winds>
            <wind type="directional" direction="1,0" speed="5 kts"/>
        </winds>
    </Wind>

    <contourmap/>
    <!-- needs to be here... -->

    <terroir name="Terroir" shared="true">

        <cache_policy usage="none"/>

        <shared_sampler>TERROIR_TEX</shared_sampler>
        <shared_matrix>TERROIR_MAT</shared_matrix>

        <shader>
            <![CDATA[
                       
                #version 430
                #pragma vp_name Terroir shader
                #pragma vp_entryPoint oe_splat_Model
                #pragma vp_location vertex_model
                #extension GL_ARB_gpu_shader_int64 : enable
                
                out vec3 splatVertex_model;
                
                void oe_splat_Model(inout vec4 vertex_model)
                {
                    splatVertex_model = vertex_model.xyz;
                }
                
              [break]
              
                #version 430
                #pragma vp_name Terroir shader (VV)
                #pragma vp_entryPoint oe_splat_View
                #pragma vp_location vertex_view
                #extension GL_ARB_gpu_shader_int64 : enable
                
                #define NUM_LEVELS 2             
                const int levels[NUM_LEVELS] = int[]( 15, 19 );
                
                vec4 oe_terrain_getNormalAndCurvature();
                vec2 oe_terrain_scaleCoordsToRefLOD(in vec2 tc, in float refLOD);
                vec4 oe_layer_tilec;

                out vec2 splatCoords[NUM_LEVELS];
                out vec3 splatTexBlend;
                
                out float splatLevelBlend;
                
                float mapToNormalizedRange(in float value, in float lo, in float hi)
                {
                    return clamp((value-lo)/(hi-lo), 0.0, 1.0);
                }
                
                void oe_splat_View(inout vec4 vertex_view)
                {
                    // texture coordinates
                    for(int i=0; i<NUM_LEVELS; ++i)
                    {
                        vec2 uv = ((i&1)==0)? oe_layer_tilec.st : oe_layer_tilec.ts;
                        splatCoords[i] = oe_terrain_scaleCoordsToRefLOD(uv, levels[i]);
                    }
                 
                    vec3 normal_model = oe_terrain_getNormalAndCurvature().xyz;   
                    
                    // triplanar blending parameters:
                    //splatTexBlend = abs(normal_model);
                    //splatTexBlend = normalize(max(splatTexBlend, 0.00001));
                    //float b = splatTexBlend.x + splatTexBlend.y + splatTexBlend.z;
                    //splatTexBlend /= vec3(b);
                    
                    // reference frame of vertex normal:
                    //vec3 normal_view = gl_NormalMatrix * normal_model;                    
                    //vec3 tangent = cross(gl_NormalMatrix*vec3(0,0,1), normal_view);
                    //vec3 binormal = cross(tangent, normal_view);
                    //oe_splat_TBN = mat3(normalize(tangent), normalize(binormal), normal_view);
                    
                    // transition b/w levels
                    const float start = 125.0;
                    const float end = 50.0;                    
                    splatLevelBlend = mapToNormalizedRange(-vertex_view.z, start, end);
                }
            
              [break]
                       
                #version 430
                #pragma vp_name Terroir shader
                #pragma vp_entryPoint oe_splat_Frag
                #pragma vp_location fragment
                #extension GL_ARB_gpu_shader_int64 : enable
                
                layout(binding=5, std430) buffer TextureLUT {
                    uint64_t texHandle[];
                };
                
                #define DENSITY 0
                #define MOISTURE 1
                #define RUGGED 2
                #define BIOME 3
                
                vec3 vp_Normal;
                in vec3 splatVertex_model;
                in vec3 splatTexBlend;
                in float splatLevelBlend;
                
                #define NUM_LEVELS 2
                in vec2 splatCoords[2];
                
                uniform float shmoo;
                flat in int maxLevel;
                
                uniform float density_power = 1.0;
                uniform float moisture_power = 1.0;
                uniform float rugged_power = 1.0;
                uniform float depth = 0.02;
                
                vec3 unpackNormal(in vec4 p)
                {
                    vec3 n;
                    n.xy = p.xy*2.0-1.0;
                    n.z = 1.0 - abs(n.x) - abs(n.y);
                    // unnecessary since Z is never < 0:
                    //float t = clamp(-n.z, 0, 1);
                    //n.x += (n.x > 0)? -t : t;
                    //n.y += (n.y > 0)? -t : t;
                    return normalize(n);
                }
                
                vec4 get_rgbh(in int index, in int level)
                {
                    return texture(sampler2D(texHandle[index]), splatCoords[level]);
                }
                
                vec4 get_material(in int index, in int level)
                {
                    return texture(sampler2D(texHandle[index+1]), splatCoords[level]);
                }
                
                float amplify(in float val, in float modifier)
                {
                    return val * modifier;
                    //return pow(val, 1.0-modifier);
                }
                                
                float threshold(in float val, in float thresh, in float buf)
                {
                    if (val < thresh-buf) return 0.0;
                    else if (val > thresh+buf) return 1.0;
                    else return clamp( (val-(thresh-buf)) / (buf*2.0), 0.0, 1.0);
                }
                
                float heightAndEffectMix(in float h1, in float a1, in float h2, in float a2)
                {                
                    // https://tinyurl.com/y5nkw2l9
                    //float depth = 0.02;
                    float ma = max(h1+a1, h2+a2)-depth;                    
                    float b1 = max(h1+a1-ma, 0.0);
                    float b2 = max(h2+a2-ma, 0.0);
                    return b2/(b1+b2);
                }
                
                vec3 triplanar(in int index)
                {
                    uint64_t h = texHandle[index];
                    const float scale = 1.0/1024.0;
                    return
                        //vec3(1,0,0) * splatTexBlend.x + vec3(0,1,0) * splatTexBlend.y + vec3(0,0,1) * splatTexBlend.z;
                        texture(sampler2D(h), splatVertex_model.yz / scale).rgb * splatTexBlend.x +
                        texture(sampler2D(h), splatVertex_model.xz / scale).rgb * splatTexBlend.y +
                        texture(sampler2D(h), splatVertex_model.xy / scale).rgb * splatTexBlend.z;
                }
                
                struct Rec {
                    int index;
                    float density_effect;
                    float moisture_effect;
                    float rugged_effect;
                    vec4 rgbh;
                    vec4 material;
                };
                
                #define NUM_TEX 3
                               
                const int TEX_ROCK  = 0; // 1 = MAT
                const int TEX_DIRT  = 2; // 3 = MAT
                const int TEX_GRASS = 4; // 5 = MAT
                
                Rec lut[NUM_TEX] = Rec[](
                    //             DEN   MOI   RUG
                    Rec(TEX_ROCK,  0.0,  0.0,  0.0, vec4(0), vec4(0)),
                    Rec(TEX_DIRT,  0.0,  0.0, -1.0, vec4(0), vec4(0)),
                    Rec(TEX_GRASS, 1.0,  1.0,  0.0, vec4(0), vec4(0))
                );
                
                float threshold(in float val, in float lo, in float hi, in float buf)
                {
                    float mid = lo + (hi-lo)*0.5;
                    float newbuf = (hi-lo)*(1.0+buf)*0.5;
                    return threshold(val, mid, newbuf);
                }
                
                
                float density, moisture, rugged;
                
                void resolveLevel(out vec3 out_color, out vec3 out_normal, int level)
                {                    
                    vec4 rgbh[NUM_TEX];
                    vec4 material[NUM_TEX];
                    
                    for(int i=0; i<NUM_TEX; ++i)
                    {
                        rgbh[i] = get_rgbh(lut[i].index, level);
                        material[i] = get_material(lut[i].index, level);
                    }

                    // starting point.
                    vec4 final_rgbh = rgbh[0];
                    vec4 final_material = material[0];
                    vec3 final_normal = unpackNormal(final_material);

                    for(int i=1; i<NUM_TEX; ++i)
                    {
                        // effect of each terroir component on this texture:
                        float e_density = density * lut[i].density_effect;
                        float e_moisture = moisture * lut[i].moisture_effect;
                        float e_rugged = rugged * lut[i].rugged_effect;
                            
                        // cummulative effect:
                        float e_total = clamp(e_density + e_moisture + e_rugged, 0, 1);

                        vec4 this_rgbh = rgbh[i];
                        vec4 this_material = material[i];
                        vec3 this_normal = unpackNormal(this_material);
                        
                        // blend with working image using both heightmap and effect:
                        //float blend = heightAndEffectBlend(this_rgbh.a, final_rgbh.a, e_total, 1.0-e_total);
                        float m = heightAndEffectMix(this_rgbh.a, e_total, final_rgbh.a, 1.0-e_total);
                    
                        final_rgbh = mix(this_rgbh, final_rgbh, m);
                        final_normal = mix(this_normal, final_normal, m);                            
                    }
                        
                    out_color = final_rgbh.rgb;
                    out_normal = final_normal;
                }
                
                
                void oe_splat_Frag(inout vec4 quad)
                {
                    // local reference frame for normals:
                    vec3 tangent = cross(gl_NormalMatrix * vec3(0,0,1), vp_Normal);
                    vec3 binormal = cross(tangent, vp_Normal);
                    mat3 tbn = mat3(normalize(tangent), normalize(binormal), vp_Normal);

                    density = quad[DENSITY];
                    density = amplify(density, density_power);
                    density = density * 2.0 - 1.0;
                    
                    moisture = quad[MOISTURE];
                    moisture = amplify(moisture, moisture_power);
                    moisture = moisture * 2.0 - 1.0;
                    
                    rugged = quad[RUGGED];
                    rugged = amplify(rugged, rugged_power);
                    rugged = rugged * 2.0 - 1.0;
                    
                    vec3 final_color;
                    vec3 final_normal;
                    
                    for(int level=0; level<=1; ++level)
                    {
                        vec3 color;
                        vec3 normal;
                        
                        resolveLevel(color, normal, level);
                        
                        if (level == 0)
                        {
                            final_color = color;
                            final_normal = normal;
                        }
                        else
                        {                            
                            float mono = (color.r*0.2126 + color.g*0.7152 + color.b*0.0722);
                            final_color = mix(final_color, (final_color*mono)*2.5, splatLevelBlend);
                            final_normal += normal * splatLevelBlend;
                        }
                    }
                        
                    // final color output:
                    quad = vec4(final_color.rgb, 1.0);
                    
                    // final normal output:
                    vp_Normal = normalize(tbn * final_normal);
                }
            ]]>
        </shader>
    </terroir>

    <tmsimage name="Terroir Debug" visible="false">
        <url>http://readymap.org/readymap/tiles/1.0.0/7/</url>
        <shader>
            <![CDATA[
                #version 430
                #pragma vp_name Terroir Debugger
                #pragma vp_entryPoint oe_splat_debug
                #pragma vp_location fragment_coloring
                
                #define DENSITY 0
                #define MOISTURE 1
                #define RUGGED 2
                #define BIOME 3                
                
                uniform float density_power = 1.0;
                uniform float moisture_power = 1.0;
                uniform float rugged_power = 1.0;
                
                uniform sampler2D TERROIR_TEX;
                uniform mat4 TERROIR_MAT;
                
                vec4 oe_layer_tilec;
                
                void oe_splat_debug(inout vec4 unused)
                {               
                    vec4 quad = texture(TERROIR_TEX, (TERROIR_MAT*oe_layer_tilec).st);
                    vec4 color;                
                    color.g = quad[DENSITY] * density_power;
                    color.b = quad[MOISTURE] * moisture_power;
                    color.r = quad[RUGGED] * rugged_power;
                    color.a = 1;      
                    unused = color;
                }
            ]]>
        </shader>
    </tmsimage>

    <xi:include href="osm_mask.xml"/>

    <xi:include href="osm_roads.xml"/>

    <xi:include href="osm_water.xml"/>

    <xi:include href="osm_buildings.xml"/>
    
    <TMSImage name="ReadyMap 15m Imagery">
        <opacity>0.25</opacity>
        <url>http://readymap.org/readymap/tiles/1.0.0/7/</url>
    </TMSImage>

</map>
